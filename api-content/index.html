{"posts":[{"title":"win系统CMD设置指令别名","content":"前言 你是否对于频繁手打ssh连接服务器感到厌烦? 你是否因习惯ls而想不起来dir指令感到DNA错乱? 使用以下方法, 设置CMD的指令别名, 解决你的痛点! (doge CMD别名设置方法 1. 建立一个批处理脚本 在你习惯的目录建立一个aliases.bat文件: @echo off chcp 65001 doskey ls=dir /b $* doskey ll=dir /ONE $* doskey cat=type $* doskey rm=del $* doskey mv=move $* doskey mkdir=md $* doskey clear=cls doskey shell=PowerShell $* doskey alias=doskey /macros doskey sshrt=ssh -p 22 rt@xxx.xxx.xxx.xxx doskey相当于Linux中的alias, 等号左边是右边的别名 $*表示这个命令还可能有其他参数 但是仅仅这样还不够, 因为doskey这个指令的别名效果仅仅在当前窗口有效, 无法持久化, 一旦关闭窗口后就会失效, 所以我们需要让每次打开cmd时都能够自动执行这个doskey脚本. 这就要借助注册表实现. 2. 编辑注册表 有时候我们希望cmd启动的时候就能执行一条或者多条命令, 但是cmd又没有linux下类似profile, bashrc这种东西. 其实cmd也有个类似的东西, 命令提示符窗口下输入cmd /?打开cmd帮助, 向下翻你会发现cmd启动的时候会搜索注册表的两个键值, 并执行这两个键值对应的命令. 这两个键值是: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\AutoRun HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\AutoRun 顾名思义, 第一个是对所有用户生效, 第二个是对当前用户生效. 这里也能够知晓, 必须将键名设置为AutoRun才会被cmd自动执行, 乱取名是没用的! 默认情况下是没有AutoRun这个键值的, 可以自己新建, 类型为字符串. 然后把要执行的命令放到一个.bat/.cmd批处理中, 然后这个键的值为该.bat/.cmd批处理的路径. 这样每次打开cmd的时候, 这个批处理都会被执行. 我的操作步骤如下: (仅供参考) 快捷键win+r唤起运行程序, 键入regedit启动注册表. 进入地址:计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor: 可以看到, 因为我这里电脑环境安装了miniforge3, 已经被miniforge3创建了一个AutoRun, 就没办法再新建AutoRun了. 所以我这里选择换用HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Command Processor\\AutoRun 去编辑全局的配置: 这里全局配置里没有其他程序建立过AutoRun键值, 我就能建一个AutoRun键值, 并配置我的bat脚本路径. 当然, 不嫌麻烦的话, 也可以和miniforge3共用AutoRun, 去编辑miniforge3的bat脚本添加你的内容, 或者在miniforge3创建的AutoRun里将数据栏的指令加上你的脚本路径应该也没问题. 不过这样就有可能因为删除miniforge3导致这个键值被删除, 或者miniforge3更新导致失效. 3. 参考文献 Settings/Windows/cmd/windows下实现类似linux下alias的命令别名.md at master · hosxy/Settings ","link":"https://UFOAlastor.github.io/PFVh7siWiZ/"},{"title":"解决bat脚本无法执行conda环境","content":"问题分析 在windows环境下, 如果使用anaconda或者miniforge的conda工具创建了python环境, 可以直接在cmd中使用conda activate指令来启动指定的环境. 但是如果直接将conda activate指令写入bat脚本中, 却无法正常执行. 例如以下bat脚本: @echo off conda activate letta letta server pause 执行bat脚本, 终端弹窗会闪一下然后直接消失. 解决方法 首先需要调用Anaconda(或miniforge)里的activate.bat来激活环境, 然后再用这个环境去运行脚本. 举个例子, 我想使用名称为letta的环境, 然后执行letta server指令, 就可以写: @echo off CALL &quot;C:\\xxx\\miniforge3\\Scripts\\activate.bat&quot; letta letta server pause 这里CALL的路径对应你电脑上部署的conda路径. 例如你安装的是anaconda, 就要去找anaconda安装路径下的xxx\\anaconda3\\Scripts\\activate.bat; 我这里是miniforge, 路径就是xxx\\miniforge3\\Scripts\\activate.bat. 这样处理后, 就可以正常启用指定的conda环境, 然后在指定环境下执行操作. ","link":"https://UFOAlastor.github.io/3BsZpFxPKL/"},{"title":"ProtoBuf协议","content":"1. 数据存储 数据采用TagLengthValue方式存储, 一条数据在protobuf二进制中的存储分为三段: Tag(标签), Length(长度), Value(数值). 每段最短都占用一个byte, 也能够每段占用多个byte, 在protobuf中每个byte最高位是一个控制位, 用来表示后续byte是否和自己属于同一个字段. 1.1. Tag(标签)字段 其中Tag(标签)存储了数据类型以及数据编号, 其编码格式为控制位 | (编号 &lt;&lt; 3) | 类型. 例如 0 | 0001 | 010 表示: 0: 后续byte和自己不属于同一个字段 1(0001): 数据编号为1 3(010): 数据类型为3 或者也可能为 1 | 0010 | 010 00000001 表示: 1: 后续byte和自己属于同一个字段 (后续byte就是指的00000001) 18(00000001 0010): 数据编号为18 (因为pb是小端法, 要换成大端法表示) 3(010): 数据类型为3 pb定义的数据类型种类如下: 1.2. Length(长度)字段以及Value(数值)字段 然后Length(长度)字段以及Value(数值)字段一样的, 开头是控制位, 置1就表示后续byte和自己是一个字段, 这样就能用多个byte表示一个字段. 1.3. 优化措施: Varint, ZigZag 其中, pb为了优化编码后的二进制长度, 还引入了Varint以及ZigZag方式进行压缩. 对于Varint编码, 其能够有效压缩小整数, 但是无法处理大整数以及负数. 方案先利用ZigZag将所有整数映射成无符号整数, 然后再采用Varint编码方式编码. 1.3.1. ZigZag ZigZag的基本思想是负数和正数进行交错编码, 使得负数映射为奇数. 处理为 0 -&gt; 0, -1 -&gt; 1, 1 -&gt; 2, -2 -&gt; 3 . 这样的好处是: 无论正负, 数值的绝对大小都能较为紧凑地表示. 具体的映射方式如下: (n &lt;&lt; 1) ^ (n &gt;&gt; 31) // 32 bit (n &lt;&lt; 1) ^ (n &gt;&gt; 63) // 64 bit 启用方式要在proto文件定义中采用sintN类型, 比如sint32, sint64. 当负数比较多的情况下就应该采用sinN类型进行定义声明. 1.3.2. Varint 和pb的开头控制位类似, Varint的最高位也是控制位, 表示后续byte是否属于这个数值的编码. 每个字节剩余的七位则用于表示实际的数字(对于小整数能够压缩, 但是大整数反而会多消耗). 作用是省略掉编码中纯0的byte, 比如int32存储数值1, 前三个byte就全是0, 就能够省略. 举个例子: 10010110 00000001 // pb的原始二进制字节流 // 10010110 开头的 1 说明后面字节 00000001 也是编码的一部分 0010110 0000001 // 丢弃每个byte开头第一位的信息位 0000001 0010110 // 由于 varint 编码时采用小端法，我们需要将其调换顺序转换为大端法 00000010010110 // 链接有效载荷 128 + 16 + 4 + 2 = 150 // 解释为无符号 64 位整数 2. 简介 protobuf是Google提出的一种数据交换的格式，是一套类似JSON或者XML的数据传输格式和规范，用于不同应用或进程之间进行通信。 特点如下: 语言无关，平台无关；Protobuf支持Java、 C++,、Python、JavaScript等多种语言，支持跨多个平台。 高效；比XML更小（3~10倍），更快（20 ~ 100倍），更为简单。 扩展性，兼容性好；可以更新数据结构，而不影响和破坏原有的旧程序。 Protobuf数据包是一种二进制的格式，相对于文本格式的数据交换（JSON、XML）来说，速度要快很多。 Protobuf的编码过程为：使用预先定义的Message数据结构将实际的传输数据进行打包，然后编码成二进制的码流进行传输或者存储。 Protobuf的解码过程则刚好与编码过程相反：将二进制码流解码成Protobuf自己定义的Message结构。 protobuf的功能是序列化&amp;反序列化, 属于应用层(表示层). 3. 安装protoc 3.1. Protocol Buffers v21.12([protobuf-3.21.12)版本 protobuf编译、安装和简单使用C++ (Windows+VS平台) - WindSun - 博客园 win10系统下使用mingw编译protobuf，并且在vscode中使用cmake配置应用_cmake编译protobuf时 vscode选什么-CSDN博客 下载: https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protobuf-cpp-3.21.12.tar.gz ./autogen.sh ./configure make &amp;&amp; make install sudo ldconfig /usr/local/lib /usr/local/lib64 protoc --version 3.2. 最新版(c++编译报错) github发布页Release Protocol Buffers v25.3 · protocolbuffers/protobuf (github.com) 其他语言可以直接安装二进制文件到PATH中, 但是c++需要编译安装: protobuf/src/README.md 位于 main · protocolbuffers/protobuf --- protobuf/src/README.md at main · protocolbuffers/protobuf (github.com) 要从源代码构建 protobuf，需要以下工具： bazel git g++ centos下需要升级g++，使用较新的g++编译器: yum install devtoolset-8-gcc devtoolset-8-gcc-c++ echo &quot;source /opt/rh/devtoolset-8/enable&quot; &gt;&gt; /etc/bashrc source /etc/bashrc bazel安装可以参考官方给的脚本:Release 7.0.2 · bazelbuild/bazel (github.com) 获取源代码，请在发布页面下载发布.tar.gz或.zip包： https://github.com/protocolbuffers/protobuf/releases/latest 构建 C++ Protocol Buffer 运行时和 Protocol Buffer 编译器 (protoc)，请执行以下命令： bazel build :protoc :protobuf 然后可以安装编译器，例如在 Linux 上： cp bazel-bin/protoc /usr/local/bin 可以成功安装, 但是c++编译报错: Person.pb.h:13:10: fatal error: google/protobuf/port_def.inc: No such file or directory #include &quot;google/protobuf/port_def.inc&quot; ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ compilation terminated. 4. 编译Protocol Buffers 确定数据格式，比如： struct Person { int id; string name; string sex; int age; }; 根据protobuf的语法, 编辑.proto文件 // Person.proto syntax = &quot;proto3&quot;; // 在该文件中对要序列化的结构体进行描述 message Person { int32 id = 1; repeated bytes name = 2; bytes sex = 3; int32 age = 4; } 使用 protoc 命令将 .proto 文件转化为相应的 C++ 文件 $ protoc -I /path/Person.proto --cpp_out=输出路径(存储生成的c++文件) 源文件: xxx.pb.cc –&gt; xxx对应的名字和 .proto文件名相同 头文件: xxx.pb.h –&gt; xxx对应的名字和 .proto文件名相同 在 protoc 命令中，-I 参数后面可以跟随一个或多个路径，用于告诉编译器在哪些路径下查找导入的文件或依赖的文件，使用绝对路径或相对路径都是没问题的。protoc -I path1 -I path2 或 protoc -I path1:path2 都表示告诉编译器在 path1 和 path2 路径下查找导入的文件或依赖的文件。 需要将生成的c++文件添加到项目中, 通过文件中提供的类 API 实现数据的序列化/反序列化 编译cpp文件: g++ MyTest.cpp Person.pb.cc -o MyTest -lprotobuf -std=c++11 -lpthread 5. proto文件 Protobuf使用proto文件来预先定义的消息格式。数据包是按照proto文件所定义的消息格式完成二进制码流的编码和解码。proto文件简单地说，就是一个消息的协议文件，这个协议文件的后缀文件名为“.proto”。 // [开始头部声明] syntax = &quot;proto3&quot;; package tutorial; // [结束头部声明] // [开始 java 选项配置] (c++不需要定义包) option java_package = &quot;tutorial&quot;; // 生成类的包名 option java_outer_classname = &quot;MsgProtos&quot;; // 生成类的类名 // [结束 java 选项配置] // [开始消息定义] message Msg { optional uint32 id = 1; //消息 ID optional string content = 2 [default = &quot;hello world&quot;];//消息内容 } // [结束消息定义] optional ：该字段可以设置也可以不设置。如果未设置可选字段值，则使用默认值。对于简单类型，您可以指定自己的默认值，就像我们在示例中为电话号码 type 所做的那样。否则，使用系统默认值：数字类型为零，字符串为空字符串，布尔值为 false。对于嵌入消息，默认值始终是消息的“默认实例”或“原型”，其未设置任何字段。调用访问器来获取尚未显式设置的可选（或必填）字段的值始终返回该字段的默认值。 repeated ：该字段可以重复任意次数（包括零次）。重复值的顺序将保留在协议缓冲区中。将重复字段视为动态大小的数组。 required：必须提供该字段的值，否则消息将被视为“未初始化”。如果 libprotobuf 在调试模式下编译，序列化未初始化的消息将导致断言失败。在优化版本中，会跳过检查，并且无论如何都会写入消息。但是，解析未初始化的消息总是会失败（通过从解析方法返回 false ）。除此之外，必填字段的行为与可选字段完全相同。required 字段受到强烈反对；proto2 语法中定义的大多数消息仅使用 optional 和 repeated（Proto3 根本不支持 required 字段。） 5.1. 枚举类型 // 要序列化的数据 // 枚举 enum Color { Red = 5, // 可以不给初始值, 默认为0 Green, Yellow, Blue }; // 要序列化的数据 struct Person { int id; string name[10]; string sex; int age; // 枚举类型 Color color; }; —&gt;.proto: // 定义枚举类型 enum Color { Red = 0; Green = 3; // 第一个元素以外的元素值可以随意指定 Yellow = 6; Blue = 9; } // 在该文件中对要序列化的结构体进行描述 message Person { int32 id = 1; repeated bytes name = 2; bytes sex = 3; int32 age = 4; // 枚举类型 Color color = 5; } proto3 中的第一个枚举值必须为 0，第一个元素以外的元素值可以随意指定。 5.2. proto的引用导入 在 Protocol Buffers 中，可以使用import语句在当前.ptoto中导入其它的.proto文件。这样就可以在一个.proto文件中引用并使用其它文件中定义的消息类型和枚举类型。 syntax = &quot;proto3&quot;; // 使用另外一个proto文件中的数类型, 需要导入这个文件 import &quot;Address.proto&quot;; // 在该文件中对要序列化的结构体进行描述 // 定义枚举类型 enum Color { Red = 0; Green = 3; // 第一个元素以外的元素值可以随意指定 Yellow = 6; Blue = 9; } // 在该文件中对要序列化的结构体进行描述 message Person { int32 id = 1; repeated bytes name = 2; bytes sex = 3; int32 age = 4; // 枚举类型 Color color = 5; // 添加地址信息, 使用的是外部proto文件中定义的数据类型 Address addr = 6; } import语句中指定的文件路径可以是相对路径或绝对路径。如果文件在相同的目录中，只需指定文件名即可。 导入的文件需要会在编译时与当前文件一起被编译 protoc A.proto B.proto --cpp_out=.。 导入的文件也可以继续导入其他文件，形成一个文件依赖的层次结构。 c++的api调用引用文件时格式为mutable_addr()-&gt;set_addr(&quot;北京&quot;), 即mutable_消息名()-&gt;同理 5.3. 包(package) 在 Protobuf 中，可以使用package关键字来定义一个消息所属的包（package）。包是用于组织和命名消息类型的一种机制，类似于命名空间的概念。 使用包可以避免不同.proto文件中的消息类型名称冲突，同时也可以更好地组织和管理大型项目中的消息定义。可以将消息类型的名称定义在特定的包中，并使用限定名来引用这些类型。 下面有两个proto文件，分别给他们添加一个package： proto文件 - Address.proto: syntax = &quot;proto3&quot;; // 添加命名空间 Dabing package Dabing; // 地址信息, 这个Address类属于命名空间: Dabing message Address { bytes addr = 1; bytes number = 2; } proto文件 - Person.proto: syntax = &quot;proto3&quot;; // 使用另外一个proto文件中的数类型, 需要导入这个文件 import &quot;Address.proto&quot;; // 指定命名空间 ErBing package ErBing; // 以下的类 Person 属于命名空间 ErBing, 在该文件中对要序列化的结构体进行描述 message Person { int32 id = 1; repeated bytes name = 2; bytes sex = 3; int32 age = 4; // 添加地址信息, 使用的是外部proto文件中定义的数据类型 // 如果这个外边类型属于某个命名空间, 语法格式: Dabing.Address addr = 6; } 6. 序列化和反序列化 6.1. xxx.pb.h 头文件 通过protoc 命令对.proto文件的转换，得到的头文件中有一个类，这个类的名字和 .proto文件中message关键字后边指定的名字相同，.proto文件中message消息体的成员就是生成的类的私有成员。 调用生成的类提供的公共成员函数访问生成的类的私有成员，这些函数格式如下： 清空(初始化) 私有成员的值: clear_变量名() 获取类私有成员的值: 变量名() 给私有成员进行值的设置: set_变量名(参数) 得到类私有成员的地址, 通过这块地址读/写当前私有成员变量的值: mutable_变量名() 如果这个变量是数组类型: 数组中元素的个数: 变量名_size() 添加一块内存, 存储新的元素数据: add_变量名() 、add_变量名(参数) 6.2. 序列化 序列化是指将数据结构或对象转换为可以在储存或传输中使用的二进制格式的过程。在计算机科学中，序列化通常用于将内存中的对象持久化存储到磁盘上，或者在分布式系统中进行数据传输和通信。 Protobuf 中为我们提供了相关的用于数据序列化的 API，如下所示： // 头文件目录: google\\protobuf\\message_lite.h // --- 将序列化的数据 数据保存到内存中 // 将类对象中的数据序列化为字符串, c++ 风格的字符串, 参数是一个传出参数 bool SerializeToString(std::string* output) const; // 将类对象中的数据序列化为字符串, c 风格的字符串, 参数 data 是一个传出参数 bool SerializeToArray(void* data, int size) const; // ------ 写磁盘文件, 只需要调用这个函数, 数据自动被写入到磁盘文件中 // -- 需要提供流对象/文件描述符关联一个磁盘文件 // 将数据序列化写入到磁盘文件中, c++ 风格 // ostream 子类 ofstream -&gt; 写文件 bool SerializeToOstream(std::ostream* output) const; // 将数据序列化写入到磁盘文件中, c 风格 bool SerializeToFileDescriptor(int file_descriptor) const; 6.3. 反序列化 反序列化是指将序列化后的二进制数据重新转换为原始的数据结构或对象的过程。通过反序列化，我们可以将之前序列化的数据重新还原为其原始的形式，以便进行数据的读取、操作和处理。 Protobuf 中为我们提供了相关的用于数据序列化的 API，如下所示： // 头文件目录: google\\protobuf\\message_lite.h bool ParseFromString(const std::string&amp; data) ; bool ParseFromArray(const void* data, int size); // istream -&gt; 子类 ifstream -&gt; 读操作 // wo ri // w-&gt;写 o: ofstream , r-&gt;读 i: ifstream bool ParseFromIstream(std::istream* input); bool ParseFromFileDescriptor(int file_descriptor); 7. 反射机制 通过.proto文件实现. .proto文件里存储了元信息, 也就是数据名称, 类型, 以及嵌套关系之类的信息. xxx.pb.cc里存储了序列化处理后的.proto内容, 以硬编码的方式保存. 硬编码的.proto元信息内容以懒加载的方式被DescriptorDatabase加载, 解析, 并缓存到DescriptorPool中. 通过反射机制, 可以自动遍历.proto中定义的数据. 这样代码编写更容易, 同时灵活性更高, 更新.proto内容后, 代码也不需要修改. ","link":"https://UFOAlastor.github.io/JFt3l7SWY/"},{"title":"数据库-事务","content":"事务 1. 事务是什么 事务是针对数据库的一系列操作条件下保证数据一致性与可靠性的概念, 定义了事务是一个不可分割的工作单元, 包含一系列数据库操作, 这些操作要么全部执行成功, 要么失败后全部回滚. 2. 事务解决什么问题 考虑一个场景: 账户转账任务, 从A账户转账100元到B账户: 第一步, 从A账户扣款100元 第二步, 向B账户添加100元 如果没有采用事务, 执行完第一步操作后网络或程序崩溃, 导致A账户扣款100元, 但是B账户没有添加100元, 这令整个账户系统中凭空消失了100元余额. 3. 事务如何解决问题 事务保证了事务中的一系列数据库操作, 要么全部执行成功, 要么失败全部回滚. 针对上述场景, 如果事务刚执行完第一步后网络或程序崩溃, 此时操作还未提交, A账户的余额未变更; 如果事务提交后, 操作B账户余额失败, 事务会通过undo log或者版本控制进行回滚. 事务通常通过以下步骤来执行: 开始事务(Begin Transaction): 事务开始, 数据库记录事务的初始状态. 执行操作(Execute Operations): 进行一系列的数据库操作(如插入, 更新, 删除等), 这些操作暂时不会提交到数据库. 检查一致性(Check Consistency): 检查所有操作是否成功执行, 确保数据仍然满足一致性约束. 提交事务(Commit Transaction): 如果所有操作都成功, 提交事务. 此时, 所有操作的结果被永久性地写入数据库. 回滚事务(Rollback Transaction): 如果有任何操作失败, 回滚事务. 此时, 撤销所有已经执行的操作, 将数据库恢复到事务开始前的状态. ACID属性 1. ACID是什么 ACID是事务具有的4个关键特性, 也是保证事务正确性的4个要求, 包含原子性, 一致性, 隔离性, 持久性. 2. ACID具体内容 2.1. 原子性(Atomicity) 事务的所有操作要么全部完成, 要么全部不完成. 事务一旦开始, 要么完全成功, 要么在出错时完全撤销, 系统不会处于不完整状态. 如果在事务执行过程中出现错误, 所有已执行的操作会被撤销, 数据回滚到事务开始前的状态. 2.2. 一致性(Consistency) 事务的一致性与&quot;分布式数据一致性&quot;含义不同: 事务的一致性强调处理前后结果应与需求预期保持一致, 是一种逻辑一致, 人为定义的规则. 事务在执行前和执行后, 数据库都必须保持一致的状态. 执行事务后, 所有的业务规则, 约束和触发器都必须被满足. 一致性确保事务执行后, 数据库从一个合法状态转移到另一个合法状态. 通过原子性, 持久性, 隔离性最终实现数据一致性. 2.3. 隔离性(Isolation) 事务的执行过程与其他事务隔离, 不会被其他事务干. 即使有多个事务同时执行, 它们的中间状态相互之间不可见, 也不会相互影响. 隔离性是一个最常放松的一个, 随着数据库隔离级别的提高, 数据的并发能力就会有所下降. 如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题. 隔离性通过两段式锁协议或三级封锁协议来实现, 划分出多种隔离级别, 常见的四种隔离级别为: 读未提交, 读提交, 可重复读和可序列化. 2.4. 持久性(Durability) 一旦事务提交, 其对数据库的修改将永久保存, 即使系统崩溃也不会丢失. 数据库通过日志或其它机制来保证数据的持久性, 即事务的结果被永久性地写入存储设备. 并发一致性问题 1. 并发一致性问题是什么 并发一致性问题指的是在并发环境下, 由于事务的隔离性很难保证, 会出现4种数据一致性问题. 2. 并发一致性问题具体内容 2.1. 丢失修改 一个事务对数据进行了修改, 在事务提交之前, 另一个事务对同一条数据进行了修改, 覆盖了之前的修改; 考虑一个场景: 假设有一个网上购物平台, 有两个用户A和B, 他们几乎同时购买最后一件商品: 用户A的事务: 检查库存数量. 扣减库存. 确认订单. 用户B的事务: 检查库存数量. 扣减库存. 确认订单. 不采用两段锁协议时可能发生如下情况: 用户A对库存数量加锁, 进行读取, 读到剩余数量为1, 读取完成后释放锁. 紧接着用户B拿到库存数量的锁, 读取剩余数量也为1, 读完后释放锁. 然后用户A和用户B都可以执行扣减库存, 因为都读取到剩余数量为1. 最后库存数量被减到-1; 或者库存被覆盖, 虽然显示为0, 但是A和B都下单成功. 2.2. 脏读(Dirty Read) 一个事务读取了被另一个事务修改, 但未提交(回滚)的数据, 造成两个事务得到的数据不一致. 考虑一个场景: A和B两个企业用户, 企业拥有共享余额, 该企业中用户可以共同进行充值或消费: 企业余额初始为0. 用户A进行充值操作, 充入100元, 企业余额增加为100元, 事务还没提交, 等待A个人余额扣款. 用户B此时想要使用企业余额消费50元, 读取到企业余额为100元, 充足, 发起扣款50元. 于此同时, 用户A个人余额扣款失败, 充值失败, 事务未提交, 数据回滚, 企业余额变回0元. 但是用户B发起了扣款50元的操作, 企业余额被减少到-50元. 2.3. 不可重复读(Nonrepeatable Read) 在同一个事务中, 某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据, 发现数据已经发生修改(针对update操作) 考虑一个场景: A和B两个企业用户, 企业拥有共享余额, 该企业中用户可以共同充值或消费: 企业余额初始为100元. 用户A想要进行消费, 第一步查询企业余额, 确定能够消费的上限. 用户B此时已经发起一个扣款操作, 消费100元, 令企业余额减为0. 用户A认为自己最多能消费100元, 发起了一个50元的扣款请求. 系统规定为了避免扣款透支, 扣款前会进行查询, 此时再次读取发现企业余额为0. 用户A的消费操作因为两次读取同一个数据发现数据被修改而被迫失败. 2.4. 幻读(Phantom Read) 当同一查询多次执行时, 由于其它事务在这个数据范围内执行插入操作, 会导致每次返回的结果集不同. 和不可重复读的区别: 针对的是一个数据整体/范围, 并且针对insert操作) 考虑一个场景: 企业要给员工发放工资, 需要统计出所有员工工资, 对企业账户进行扣款, 以及员工账户进行加款, 企业原本共10名员工, 每个员工固定工资3k: 事务A: 查询所有员工, 统计出总额10×3k=3w10\\times 3k=3w10×3k=3w, 对企业账户扣款3w. 此时另一个事务B: 新增两名员工, 工资同样3k, 更新员工表. 事务A: 对全体员工发放3k的工资, 查询所有员工, 读取到12名员工, 每人3k工资. 因为事务A查询员工返回的结果集改变, 员工得到的工资总额为12×3k=3.6w12\\times 3k=3.6w12×3k=3.6w. 对账户系统而言, 员工账户到账总额超出企业账户扣款, 发生错误. 事务的数据一致性保证 1. 两段锁协议 1.1. 两段锁协议是什么 两段锁协议(Two-Phase Locking, 2PL)是一种通过将事务执行过程分为两个阶段以确保数据库事务之间隔离性的方法, 用来防止并发一致性问题, 保证事务调度串行化. 1.2. 两段锁协议解决什么问题 两段锁协议没有规定锁类型, 采用最严格的表级排他锁, 能够解决全部并发一致性问题: [[事务#2.1. 丢失修改]]. [[事务#2.2. 脏读 (Dirty Read)]]. [[事务#2.3. 不可重复读(Nonrepeatable Read)]]. [[事务#2.4. 幻读(Phantom Read)]]. 1.3. 两段锁协议如何解决问题 两段锁协议规定事务执行过程分为&quot;扩展阶段&quot;与&quot;收缩阶段&quot;: 扩展阶段(Growing Phase): 事务申请和获取所有需要的锁, 在这个阶段不能释放任何锁. 收缩阶段(Shrinking Phase): 扩展阶段结束后, 释放申请的所有锁, 不能再申请新的锁. 两段锁协议保证了在事务提交以前, 所有所需的数据都无法被其他事务进行读取或修改. 丢失修改: 事务提交前其他事务无法修改当前事务占有的数据. 脏读: 事务提交前其他事务无法读取当前事务修改的数据. 不可重复读: 事务提交前其他事务无法修改当前事务占有的数据, 数据不可能发生变化. 幻读: 事务提交前其他事务无法修改当前事务占有的数据范围, 数据不可能发生变化. 两段锁协议的两个阶段并没有限制对数据的操作, 拿到锁之后就可以进行进行数据的读写, 例如在扩展阶段的中途, 读写已经拿到锁的数据; 或者在收缩阶段的中途, 读写还未释放锁的数据. 如果事务遵循两段锁协议, 那么它们的并发调度是可串行化的: 两段锁是可序列化的充分条件, 但不是必要条件. 采用两段锁协议也有可能产生死锁, 这是因为每个事务都不能及时解除被它封锁的数据, 可能会导致多个事务互相都要求对方已封锁的数据不能继续运行. 2. 三级封锁协议 2.1. 三级封锁协议是什么 三级封锁协议是对两段锁协议的细分讨论, 划分了三级封锁级别, 实现比两段锁协议更细粒度的并发控制, 可以根据需求选择不同级别的封锁方式以换取并发性能. 2.2. 三级封锁协议解决什么问题 2.2.1. 一级封锁协议 可以解决丢失修改问题: [[事务#2.1. 丢失修改]]. 2.2.2. 二级封锁协议 可以解决脏读问题: [[事务#2.2. 脏读 (Dirty Read)]]. 2.2.3. 三级封锁协议 可以解决不可重复读问题: [[事务#2.3. 不可重复读(Nonrepeatable Read)]]. 使用表级锁可以解决幻读问题: [[事务#2.4. 幻读(Phantom Read)]]. 2.3. 三级封锁协议如何解决问题 2.3.1. 一级封锁协议 事务修改数据之前必须先加X锁(排他锁), 直到事务结束才释放. 一级封锁协议类似于两段锁协议, 但是仅规定了修改数据需要加锁, 没有对数据读取加以限制. X锁(排他锁)不能与其他锁共存, 无法抢占加了S锁的数据, 加了X锁后其他事务无法再加S锁. 通过在事务期间持续持有排他锁, 避免了其他事务对当前事务占有数据进行修改, 避免了事务提交前数据修改被其他事务修改覆盖. 2.3.2. 二级封锁协议 在一级封锁协议基础上, 事务在读取数据前必须先加S锁(共享锁), 读取完成后即可释放. S锁(共享锁)允许与其他事务的S锁共存, 允许对数据进行读取, 但是不能修改数据. 如果有其他事务想要修改数据, 就意味着已经对该数据添加了X锁, 当前事务就无法添加S锁, 也就无法读取数据, 避免读取到脏数据. 反过来说, 当前事务能够添加S锁, 说明没有其他事务准备对该数据进行修改, 指导释放S锁之前, 其他事务也无法添加X锁. 2.3.3. 三级封锁协议 在二级封锁协议基础上, 事务在读取数据前必须先加S锁, 并且直到事务提交才能释放. 针对事务期间可能存在的需要多次读取同一数据的场景, 事务期间持续持有S锁, 避免了其他事务对数据进行修改, 实现了对不可重复读问题的解决. 此外, 使用表级锁, 可以避免所需数据范围内发生插入或修改, 解决幻读问题. 3. 四种隔离级别 3.1. 四种隔离级别是什么 对于事务的ACID性质, 隔离性一般常被弱化, 因为隔离性越高, 事务的调度并发性能越低. 所以往往要在隔离性与并发性能之间进行权衡, 因此数据库系统划分出多种隔离级别, 用来描述事务的隔离性程度. 常见的方式将隔离级别划分为4种: 未提交读, 已提交读, 可重复读, 可序列化. 3.2. 四种隔离级别具体内容 3.2.1. 未提交读 (Read Uncommitted) 未提交读描述为事务能够读取其他事务还未提交的修改, 是最低的隔离级别. 一般而言, 丢失修改是数据库系统完全不可接受的, 所以实际场景种数据库至少采用了一级封锁协议保证不会发生丢失修改. 而未提交读则是在不存在丢失修改的基础上, 什么也不另外规定, 允许事务读取其他事务未提交的修改, 留下导致&quot;脏读&quot;的隐患, 是最低的隔离级别. 3.2.2. 已提交读 (Read Committed) 已提交读描述为事务只能读取到其他已提交事务的数据, 可以避免脏读问题. 已提交读是通过二级封锁协议实现的, 只有其他事务提交后才会释放X锁, 才能读取数据. 已提交读还存在&quot;不可重复读&quot;问题(同一事务内两次读取的数据不一致). SQL Server, Oracle的默认级别为已提交读(read committed). 3.2.3. 可重复读 (Repeatable Read) 可重复读描述为事务可以多次读取同一数据且保持一致, 可以避免不可重复读问题, 可重复读是通过三级封锁协议实现的, 只有事务提交后才会释放S锁, 其他事务无法修改数据. 可重复度还存在“幻读”问题(事务前后读取的数据范围内条目增加). MySQL的默认级别为可重复读(repeated read). 3.2.4. 可序列化 (Serializable) 可序列化描述为事务的调度可以实现序列化, 是最高级别的隔离, 可以避免幻读问题. 可序列化是通过三级封锁协议配合表级锁实现, 或者通过两段锁协议实现. 可序列化就解决了全部并发一致性问题, 但是事务调度序列化, 并发性能最差, 一般不使用. ","link":"https://UFOAlastor.github.io/24x6cGKiy/"},{"title":"quorum与paxos与raft","content":"总结 quorum问题: 脏读 -&gt; 多数派读解决 多数派读写问题: 丢失修改(未提交数据覆盖已提交数据) -&gt; paxos解决 paxos问题: 活锁 -&gt; multi-paxos解决 multi-paxos问题: 数据可用性低(没有数据追赶) -&gt; raft解决 quorum 1. quorum是什么 quorum是一个利用投票机制保证数据冗余以及强一致性的算法. 与多数派读写的区别在于, 多数派读时要求读取到占多数的相同数据才认定是最新成功提交的数据; 而quorum读取超过半数的容灾单元至少能读到一个最新数据, 数据新旧的区分没有规定, 可以采用版本号等方式. 2. quorum解决什么问题 分布式系统中需要冗余数据保证数据可靠性, 如果没有[[数据冗余]], 搭载数据的节点掉线就会导致数据无法访问. 3. quorum如何解决问题 quorum要求每次写入时超过半数容灾单元成功写入, 即可认为写入操作成功. 牺牲一定读操作性能, 每次读取超过半数的冗杂单元就能保证至少读到一个最新数据. 但是纯粹的多数派决议会引入新的问题, quorum制定了投票机制进行解决. 3.1. 投票机制 3.1.1. 投票机制是什么 投票机制是保证数据写入串行化以及针对同一数据不会同时发生读写操作而制定规则. 3.1.2. 投票机制解决什么问题 如果仅仅采用普通多数派决议方案, 当数据写入如果没有串行化, 也就是并发执行时, 会导致如下问题, 假设一个场景: 有A, B, C三台容灾单元, 此时客户端发来三个提案, 针对同一个变量x进行写入: 提案一: 写入x=1 提案二: 写入x=2 提案三: 写入x=3 三个提案同时并发提交申请, 由于网络传输存在延迟, 这时可能发生如下先后顺序: 提案一x=1写入容灾单元B, 提案x=1还没有满足多数派写入, 等待其他节点回应 提案二x=2写入B, C, x=2覆盖了B上的x=1, 提案x=2满足多数派写入, 返回提案通过 x=3写入C, A, x=3覆盖了C上的x=2, 提案x=3满足多数派写入, 返回提案通过 迟到的提案一x=1写入A, 其中x=1覆盖了A上的x=3, 提案x=1满足多数派写入, 返回提案通过 三个提案都返回写入成功, 但是三台容灾单元上分别存储了x=1, x=2, x=3. 进行多数派读写时发现读不出任何数据, 任何一个提案都不满足多数派读取. 导致了三个提案都返回写入成功, 却无法正确读取其中任何一个提案提交的数据. 同一条数据同时发生读写, 会发生以下问题, 考虑一个场景: 有A, B, C三台容灾单元, 同时针对数据x进行读写请求, 原始数据如下: A, B上x=1, C上x=3 写入x=2, 将x=2写入B 同时发生读取请求, 读取到A, B, C上分别是x=1, x=2, x=3, 读取失败 如果在读取与写入并行发生时就阻止其中一个操作, 那么另一个操作只需要等待重试; 但是并发执行读写时, 读取操作要等待完全部容灾单元回应后才能发现数据不满足多数派读, 造成了额外的开销. 3.1.3. 投票机制如何解决问题 quorum规定了一个投票机制, 要求如下: 每个容灾单元针对一条数据持有一票, 每次读写某一数据需要投票决策. 针对一个数据的投票限制如下: 写入准许票数 &gt; 容灾单元数/2 读取准许票数 &gt; 容灾单元数 - 写入准许票数 这两个规定中, 第一点限制要求了每次写入操作需要获得超过半数的容灾单元投票准许, 保证了同一数据写入的串行化; 第二点限制保证了针对同一数据, 读取操作和写入操作不会同时发生. paxos 1. paxos是什么 paxos是采用三段式提交(Three-Phase Commit)的多数派决议来保证数据一致性的算法. 基础的paxos协议存在活锁问题, 由后续multi-paxos通过串行化解决. 2. paxos解决什么问题 已知普通多数派协议存在问题[[quorum与paxos与raft#3.1.2. 投票机制解决什么问题]], 如果在仅仅普通多数派协议基础上添加提案编号也依旧存在问题, 考虑以下场景: A, B, C三个容灾单元, 此时提出三个提案, 内容都为修改x数值: 提案一: 编号=1, 修改x=1 提案二: 编号=2, 修改x=2 提案三: 编号=3, 修改x=3 考虑两段式提交, 第一阶段发起提案, 第二阶段接收到提案后立马回应: 提案一x=1写入A, B, 满足多数派决议, 提案一确认通过 提案二x=2写入B, C, 满足多数派决议, 提案二确认通过 提案三x=3写入C, 但发生丢包而未达到A, B, 不满足多数派, 提案三未通过 对于已经通过的两个提案而言, 由于A, B, C三分别存储的x=1, 2, 3, 读取时会发现尽管有两个修改x的提案通过, 但是读取时无法读到多数派结果, 造成错误. 原因是带编号的多数派协议仅规定只要当前提案编号大于容灾单元曾经接受的最大编号, 就会直接将当前提案写入容灾单元, 可能造成最终不满足多数派决议的脏数据被直接写入节点. (丢失修改) 3. paxos如何解决问题 paxos定义了三种角色, proposer(提议者), acceptor(决议者), learner(学习者). 对于一个proposal(提案), 除了第一阶段(发起阶段), paxos还分为prepare(准备阶段)和accept(批准阶段). 在准备阶段中, 由proposal向所有acceptor发送一个提案编号, 然后等待acceptor回应. acceptor收到提案编号, 进行比较, 如果该编号大于曾经收到的最大提案编号, 就记录下该编号, 并对这个提案做出承诺: 遇到不大于该提案编号的其他提案会直接拒绝; 否则拒绝这个提案. 如果proposal得到了多数acceptor接受的回应, 进入下一阶段; 否则提案失败. 在批准阶段中, proposal将带有编号的提案发送给所有acceptor, 等待回应. acceptor接受到带有编号的提案后, 如果编号大于曾经收到的最大编号, 这时才接受提案, 并以leaner身份学习提案; 如果编号不大于曾经收到的最大编号, 就忽略该提案. proposal收到多数派的acceptor接受回应后, 才认为提案通过. 这里的思路就是, 第一轮准备阶段, 提案本身并不会被执行, 甚至不需要发送, 而是先通过提案编号进行“占坑”, 当“占坑”通过后才进入批准阶段, 发送提案本身. multi-paxos 1. multi-paxos是什么 multi-paxos是在paxos协议基础上, 添加了leader概念保证决议过程串行化. multi-paxos作为强一致性协议已经足够完善, 但是没有要求数据追赶, 数据可靠性低于raft. 2. multi-paxos解决什么问题 对于基础的paxos协议, 存在活锁情况, 考虑以下场景: A, B, C三台容灾单元, 提出两个提案, 内容都为修改x的值, 分别如下: 提案一, 修改x=1 提案二, 修改x=2 姑且忽略具体编号, 假设编号按照以下出现顺序递增: 提案一, 准备阶段, 得到A, B, C中任意多数派回应, 正要进入批准阶段. 提案二, 准备阶段, 因为编号更大, 覆盖了A, B, C中多数派的承诺, 正要进入批准阶段. 提案一因为被截胡, 超时重试, 开启新一轮提案, 内容还是修改x=1, 但是编号更新后增大. 提案二而后又被更新编号的提案一截胡, 没能等到多数派回应, 同样发起重试. 如此往复, 提案一与提案二相互截胡, 导致没有任何提案通过多数派批准, 形成活锁. 即便通过限制重试次数跳出活锁, 但是依旧会造成时间消耗. 3. multi-paxos如何解决问题 multi-paxos增加了leader概念, 通过选举得出一个任期属性的leader, 规定提案只能由leader提出, 其他容灾单元称为follower, 与leader一同进行多数派决议; follower通过定时轮询(心跳)确认leader存活, leader失联后进行重新选举, 每一轮选举的任期递增. 由于选取了一个全权负责提出提案的leader, 所以实现了串行化操作, 并且由于不存在并发, 所以也不需要准备阶段, 每次提案直接进入批准阶段等待多数派回应即可, 就不会发生活锁情况. 接下来介绍一下leader的选举过程: 概念的提出者并没有明确规定选举方式, 一般而言, 可以使用basic-paxos的三段式提交进行leader的选举(因为选举是低频事件, 添加重试次数限制后可以容忍三段式提交的活锁缺陷). 至于leader的任期, 是为了避免网络分区恢复后发生同时存在多个leader的情况. 通过每次提案中带有发起者的任期可以直接让恢复的旧leader接收到新leader提案消息后主动降为follower, 其他容灾单元接收到旧leader的提案后判断出其任期更旧也会进行忽略, 从而避免因为存在多个leader而退化为普通多数派决议. raft 理解 Raft 分布式共识算法 | 指 间 (zhenchao.io) 1. raft是什么 raft与multi-paxos都是能够保证数据一致性的多数派决议方案, 但是raft比multi-paxos更进一步要求了日志序列化, 并保证follower的日志与leader日志达成最终一致性. (数据追赶) 2. raft解决什么问题 对于multi-paxos而言, 每个提案仅需要多数派回应并学习, 也没有要求数据追赶, 这样可能导致如下情况: A, B, C三台容灾单元, 其中存储的数据如下: A上存储x=1 B与C上存储x=2 如果B或C掉线, 就会导致数据x无法读取得到多数派结果, 数据可靠性低. 3. raft如何解决问题 由于leader唯一, 提案串行化执行, 所以leader的日志天然满足序列化. 此外raft规定了follower应该与leader的日志保持一致, 否则不能参与决议, 优先数据追赶. 同时raft对于选举过程增加了额外规定, 保证了选举得出的leader持有最多的日志: 对于选举时, 每个容灾单元仅持有一票, 候选者可以投自己一票, 并向其他容灾单元发出带有自己日志信息的投票请求: 其他容灾单元接收到投票请求时, 判断候选者持有的日志是否不少于于自己, 如果是则投票. 因为日志就是由多数派决议得出的, 所以多数容灾单元都持有最多的日志, 对于非最多日志持有者就不可能在选举中获得多数选票, 保证了选举得出的leader持有最多日志. 此外, raft还引入了随机选举延时(randomized election timeouts), 不同的容灾单元会在leader失联后等待一段随机时间后发起选举请求, 用以错开候选人, 避免选举过程出现平票. ","link":"https://UFOAlastor.github.io/2lEd0eWPD/"},{"title":"校园网AP隔离-内网穿透实现","content":"引言 好久没更新博客了~ 校园网有隔离, 没法直接远程桌面. 正好手头上有服务器, 做个内网穿透试试. frp内网穿透 frp下载: fatedier/frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet. (github.com) 编写service文件 服务端frps(有公网IP的服务器): frps.service [Unit] Description=Frps Server Service After=network.target [Service] Type=simple User=root Restart=on-failure RestartSec=5s ExecStart=/usr/bin/frps -c /etc/frps/frps.ini [Install] WantedBy=multi-user.target 客户端frpc(需要被远程桌面的电脑): frpc.service [Unit] Description=Frpc Client Service After=network.target [Service] Type=simple User=root Restart=on-failure RestartSec=5s ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini ExecReload=/usr/bin/frpc reload -c /etc/frpc/frpc.ini [Install] WantedBy=multi-user.target 将两份文件分别放入对应主机的路径(linux系统): /lib/systemd/system/ 启动指令: #启动frp客户端 sudo systemctl start frpc #启动frp服务端 sudo systemctl start frps #配置开机启动 sudo systemctl enable frpc sudo systemctl enable frps 编写ini配置文件 服务端frps(有公网IP的服务器, 我这里是阿里云的服务器): [common] bind_port = *frp端口* dashboard_port = 6677 vhost_http_port = 8080 token = *frp加密token* dashboard_user = *管理面板的账户名* dashboard_pwd = *管理面板的账户密码* 客户端frpc(需要被远程桌面的电脑, 我这里是实验室的Ubuntu): [common] server_addr = *服务器的公网ip* server_port = *frp端口* token = *frp加密token* [http] type = http local_ip = 127.0.0.1 *本地ip* local_port = 8080 custom_domains = xxx.alastor.top [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 *本地ssh端口* remote_port = 2222 *用于远程连接要输入的端口* [desktop] type = tcp local_ip = 127.0.0.1 local_port = 3389 remote_port = 1412 遇到的问题: 和phpStudy冲突 搞了两天, 一直连不上, 还换了nps试试, 都是管理面板上不去, 连接也连接不上. 怀疑过phpstudy的问题, 但是没有报端口错误啥的, 我就没在意, 只是把phpstudy面板关闭了试试, 都不行. 后面给我整红温了, 无语了, 直接把phpStudy卸载了, 诶, 您才怎么着? 好了…… 真离谱, 不过phpstudy确实用的人也少, 网上也没搜到是这个原因造成的, 给我折腾这么久, 吐了. 连接方式 win系统推荐直接用windows自带的remote desktop即可, 方便轻量, 而且很流畅 ","link":"https://UFOAlastor.github.io/N6PkLgMlT/"},{"title":"给Python Pip install加速的方法总结","content":"1：如果没开代理，就改成国内的源，这个我没有试过，百度一搜，很多，速度也很快，缺点就是可能不是最新的库。 2：如果有代理，那就在CMD窗口设置加入代理。 set http_proxy=http://127.0.0.1:7890 set https_proxy=http://127.0.0.1:7890 3：如果用的是Clash，默认情况下开了system Proxy的时候，这时候反而无法进行Pip install，会报错，关掉代理才能下载，这需要做如下设置。 在setting的System Proxy界面，将Specify Protocol打开。 ","link":"https://UFOAlastor.github.io/f4oNFNm6C/"},{"title":"Clash共享热点","content":"前言 Switch更新系统的时候, 发现网络不行, 要搞个梯子, 尝试用Clash通过电脑热点共享网络给Switch使用. 步骤 开启Allow LAN与TUN MODE这两个选项 开启电脑热点(共享连接选项就是默认的即可) 进入 控制面板-&gt;网络和Internet-&gt;网络连接 这里开启热点后才会显示出“本地连接*xx”这个连接, 不过我们不动他, 我们要修改的是Clash这个 点击“属性” 点击“共享”, 然后打开“其他网络用户通过此计算的Internet 连接来连接（ N ）”, 选择“本地连接” ","link":"https://UFOAlastor.github.io/vFXe4yTCm/"},{"title":"全错排问题dp公式详解","content":"前言 刷题的时候又遇到全错排问题, 本来是一个很熟悉动态规划问题, 不过我按照模糊的记忆来写状态转移方程的时候发现写错了, 于是决定搜搜看相关的公式详解, 配合着理解来巩固记忆. 不过翻了几篇文章, 都是几乎一样的解释, 而且我都不是很能理解, 感觉没有解释清楚情况数如何避免重叠和不遗漏的问题. 于是写一篇我的理解, 希望能够帮助到你. dp状态转移方程 首先, 先放上经典的公式: dp[n]=(n-1)*(dp[n-1]+dp[n-2]) 分步骤理解 首先我们考虑一个长为n的有序排列: 1, 2, 3, ..., n-1, n 其中假设前n-1中有一个数为k: 1, 2, 3, ..., k, ..., n-1, n 我们取出这个k, 共有(n-1)种情况, 用[]表示空位置 1, 2, 3, ..., [], ..., n-1, n 然后将k放在n的位置上, 将n拿在手里 1, 2, 3, ..., [], ..., n-1, k 然后手里的n能够放在哪里, 有两种情况: n放在原本k的位置上, 即 1, 2, 3, ..., n, ..., n-1, k 这样这个序列已经固定了n和k的位置, 剩下n-2个数要全错位, 即dp[n-2]种情况. n不放在原本k的位置, 这个问题可以转变为前n-1个数全错排(因为n不能放在原本k的位置, 就相当于把n看作k), 这时候的情况数就是dp[n-1]个. 不会遗漏: 我们将前n-1个数中取k都考虑到, 然后k固定在了n的位置上, 最后能否将n放在原本k的位置上也考虑到, 所以不会遗漏. 不会重叠: n的位置只有两种情况, 放在k的位置上, 或者不放在k的位置上, 这两种情况相互独立, 不会重叠. 所以总的情况数就是: dp[n]=(n-1)*(dp[n-1]+dp[n-2]) 得证. 最后符一张便于记忆的图片: ","link":"https://UFOAlastor.github.io/dINiyO1Ih/"},{"title":" 关于java8安装时点击下一步就消失的bug","content":"前言 minecraft的RLcraft更新1.9.2版本了, 想着赶紧玩一下, 发现以前安装的java8竟然是x86的, 启动12.2版本报错内存泄漏. 去官网下了个x64的java8(jdk-8u301), 结果安装时点击“下一步”直接消失了, 我还以为安装包有问题, 又去网上找了好几个版本, 折腾了半天, 一直都是点击“下一步”就闪退消失, 给我整不会了. 解决 网上搜了半天, 最后发现是百度输入法的问题 (我真的会谢 安装java的时候切掉百度输入法就行, 不用关闭输入法, 就在安装的时候切换成其他输入法就行. ","link":"https://UFOAlastor.github.io/gn3K3cu5d/"},{"title":"石蒜摇 | vscode插件发布","content":"前言 逛B站看到itorr大佬做的石蒜模拟器，太魔性了，根本停不下来，就打算移植到vscode插件里 原作者 Original Author：卜卜口 itorr 原项目仓库 OriginalGit：https://github.com/itorr/sakana 移植者 Transplanter：Zander Alastor vscode插件仓库 ExtensionGit：https://github.com/UFOAlastor/sakana-hop 插件安装可以直接在vscode插件市场中搜索石蒜 成品展示 功能概况 Overview 支持放大缩小人物 点击人物正下方按钮切换人物 拖动人物正下方按钮移动人物 自动模式，自动摇摆 语言切换 E: Supports zooming in and out of characters Click the button below the character to switch the character Drag the button below the character to move the character Automatic mode, automatic swing Language switching 安装问题 Install 若依赖启动失败： windows可尝试使用以管理者身份运行vscode mac 请留意是否将vscode从【下载】移动到【应用程序】里 mac 可通过【检查vscode是否可以更新】来判断软件是否处于可写的硬盘中 E: If the dependency startup fails: Windows can try running vscode as administrator Mac: please pay attention to whether to move vscode from [Download] to [application] the Mac can determine whether the software is in the writable hard disk by checking whether the vscode can be updated 卸载注意！ Uinstall！ 先进入插件设置取消勾选“启动” 直接删除插件会导致注入vscode的js代码未被删除 如果已经直接删除插件，图像还存在于vscode上，请进入以下路径手动删除： (旧版本vscode) C:\\Users\\your_id\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\vs\\code\\electron-browser\\workbench\\ (新版本vscode) C:\\Users\\your_id\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\vs\\code\\electron-sandbox\\workbench\\ 文件目录下只有workbench.js和workbench.html是原始文件，其余皆为插件注入的文件 其中workbench.js内第三行起由注释包裹部分也是注入的数据，若依旧存在需要手动删除 E: Firstly, uncheck &quot;start&quot; in extension settings Deleting the extension directly will cause the JS code injected into vscode not to be deleted! if the extension has been deleted directly and the image still exists on vscode, please enter the following path to delete it manually: (old version vscode) C: \\ users \\ your_ id\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\vs\\code\\electron-browser\\workbench\\ (new version vscode) C: \\ users \\ your_ id\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\vs\\code\\electron-sandbox\\workbench\\ in the file directory, only workbench.js and workbench.html are original files, and the rest are files injected by extensions the part wrapped by comments in the third line of workbench.js is also the injected data. If it still exists, it needs to be deleted manually ","link":"https://UFOAlastor.github.io/qvDrVg_o2/"},{"title":"香色闺阁书源制作教程","content":"前言 手上有部老ipadmini2，放着吃灰不好，就拿来做看书看漫画专用机。 哔哩哔哩漫画乘着活动充了50元，但还是不够划算，继续充钱有点亏，就研究了几个开源漫画软件。 目前我看下来ios上其实比较好的是源阅读，但是ipadmini2系统只到ios12.5，源阅读最低要求ios13，恶心人。 香色闺阁非常友好的支持了我的mini2，所以我现在主力漫画软件就是香色闺阁。 但是香色闺阁的xbs加密源文件属实也是恶心人，只能用ios设备编辑，不能在电脑上编写，好在本身很简单，原理就是个简易版爬虫。 从一次实战开始 最近喜欢看英文版日漫，边娱乐边复习六级（属于是给看漫画找借口了） 但是已有的香色闺阁漫画源中英文书源较少，所以打算自己写一个 选的网站是bato.to，一个资源非常全，而且可以大陆直连的网站 新建站点 进入香色闺阁软件，点击左面的站点管理，点击更多，选择新建站点 这里我已经把基础内容填写完成了 大部分选项的含义和作用都是一目了然的，这里只挑几个重点讲一下 “权重”：该站点在列表中排列的先后顺序，最大值9999，不过好几个源作者都喜欢标9999，而且xbs还加密（说的就是你益达源），总体上没什么用，你编辑站点的时候可以直接顶置，方便反复修改 “httpheaders”：cookie装里面，有些站点可能要登入才能查看某些资源，cookie的获取方式可以直接百度 一个示例： {&quot;Cookie&quot;:&quot;XXX&quot;,&quot;User-Agent&quot;:&quot;Mozilla\\/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit\\/537.36 (KHTML, like Gecko) Chrome\\/96.0.4664.110 Safari\\/537.36&quot;} 常用配置部分 书籍搜索 进入你的目标网站，搜索某个很常见的关键词，保证有多页结果，然后翻到比如第4页，记住上面的连接格式 https://bato.to/search?word=game&amp;page=4 修改为下面这种格式： https://bato.to/search?word=%@keyWord&amp;page=%@pageIndex 响应规则里面按照格式填写，具体的div，class之类的通过F12打开目标网页源文件查看 格式很简单 // 开头 div或img之类的对应&lt;div &gt;, &lt;img &gt; @ 用来定位class或者id 要获取&lt;div src=&quot;xxx&quot;&gt;里面的src时也是用@src “更多配置”这一块，在制作小说源的时候要调一下编码为中文编码，我们这里是漫画，不用管文本编码 书籍详情 详情这一块，接触文本会比较多一点，可能需要借助js格式化一些段落，或去除一些无用标记 这里举个例子，可以参考一下（去除多余的网页br格式） //div[@id='limit-height-body-summary']/div[@class='limit-html'] || @js: let reg = new RegExp('&lt;br /&gt;', 'g') return result.replace(reg, '') 章节列表 这里的“下一级界面地址”要注意，可能会有坑 我这里的bato.to网站就遇到坑了 bato.to网站的章节链接不是完整URL，而是相对网站主域名的相对路径，直接使用就会 “ URL错误，没有URL编码? “ 这样报错 手动调整一下，保证是完整的URL传出： //a[@class='visited chapt']/@href || @js: let url = 'http://bato.to' +result; return url; 章节内容 章节内容就是我们最关键的漫画图片部分 使用“蓝色框框”中的元素检查工具，点击“绿色宽宽”中的也就是漫画图片部分，然后下方开发者工具就会跳转出来相应的源码部分 我们关注两个“红色框框”中的内容，src是我们漫画图片的直接地址，class用来定位这个部分，辅助我们得到src 这个网站还有个坑，漫画图片加载是js动态加载，直接爬取网页得不到图片 这里请求信息我们要加上webView （这类js加载的网站第一次打开某本漫画会比较慢，要加载完全部资源才会在软件上显示出页码） 请求信息： @js: return {'url':result, 'webView':&quot;&quot;}; 之后正文部分还是一样的 正文： //img[@class='page-img']/@src 书籍分类 整体还是大同小异，不过这一部分要手动配置的内容比较多，我就直接上截图和代码了 请求信息： @js: return 'https://bato.to/browse?genres=' + params.filters.genre1 + ',' + params.filters.genre2 + ',' + params.filters.genre3 + ',' + params.filters.genre4 + '&amp;langs=' + params.filters.translated + '&amp;origs=' + params.filters.original + '&amp;release=' + params.filters.release + '&amp;chapters=' + params.filters.chapters + '&amp;sort=' + params.filters.sort + '&amp;page=' + params.pageIndex; 更多配置-moreKeys：（全是标签） {&quot;pageSize&quot;:60,&quot;requestFilters&quot;:[{&quot;items&quot;:[{&quot;value&quot;:&quot;&quot;,&quot;title&quot;:&quot;All&quot;},{&quot;value&quot;:&quot;artbook&quot;,&quot;title&quot;:&quot;Artbook&quot;},{&quot;value&quot;:&quot;cartoon&quot;,&quot;title&quot;:&quot;Cartoon&quot;},{&quot;value&quot;:&quot;comic&quot;,&quot;title&quot;:&quot;Comic&quot;},{&quot;value&quot;:&quot;doujinshi&quot;,&quot;title&quot;:&quot;Doujinshi&quot;} 。。。。。。 {&quot;value&quot;:&quot;zombies&quot;,&quot;title&quot;:&quot;Zombies&quot;}],&quot;key&quot;:&quot;genre4&quot;},{&quot;items&quot;:[{&quot;title&quot;:&quot;All&quot;,&quot;value&quot;:&quot;&quot;},{&quot;title&quot;:&quot;ar&quot;,&quot;value&quot;:&quot;ar&quot;},{&quot;title&quot;:&quot;en&quot;,&quot;value&quot;:&quot;en&quot;},{&quot;title&quot;:&quot;es&quot;,&quot;value&quot;:&quot;es&quot;},{&quot;title&quot;:&quot;pt&quot;,&quot;value&quot;:&quot;pt&quot;},{&quot;title&quot;:&quot;it&quot;,&quot;value&quot;:&quot;it&quot;},{&quot;title&quot;:&quot;pl&quot;,&quot;value&quot;:&quot;pl&quot;},{&quot;title&quot;:&quot;id&quot;,&quot;value&quot;:&quot;id&quot;}, 。。。。。。 {&quot;title&quot;:&quot;Pending&quot;,&quot;value&quot;:&quot;pending&quot;},{&quot;title&quot;:&quot;Ongoing&quot;,&quot;value&quot;:&quot;ongoing&quot;},{&quot;title&quot;:&quot;Completed&quot;,&quot;value&quot;:&quot;completed&quot;},{&quot;title&quot;:&quot;Hiatus&quot;,&quot;value&quot;:&quot;hiatus&quot;},{&quot;value&quot;:&quot;50&quot;,&quot;title&quot;:&quot;50+&quot;},{&quot;value&quot;:&quot;10&quot;,&quot;title&quot;:&quot;10+&quot;},{&quot;value&quot;:&quot;1&quot;,&quot;title&quot;:&quot;1+&quot;}],&quot;key&quot;:&quot;chapters&quot;},{&quot;items&quot;: 。。。。。。 {&quot;value&quot;:&quot;views_w.za&quot;,&quot;title&quot;:&quot;7days&quot;},{&quot;value&quot;:&quot;views_d.za&quot;,&quot;title&quot;:&quot;24hours&quot;},{&quot;value&quot;:&quot;views_h.za&quot;,&quot;title&quot;:&quot;60minutes&quot;}],&quot;key&quot;:&quot;sort&quot;}]} 更多配置 比如书单啊，广场啊，热词啥的，因为不是必须品，我这里就不继续写教程了 想做的话和上面的例子都是大同小异，按照格式制作即可 Bato.to.xbs 还有不懂的地方可以下载这个样例xbs xiangseguige/书源 at main · UFOAlastor/xiangseguige (github.com) ","link":"https://UFOAlastor.github.io/Wkl8lfAOP/"},{"title":"document.querySelector错误返回null","content":"前言 给小站加上右侧边 —&gt; 这个彩色动态滚动条的时候，遇到了js无法修改css的问题 排查之后发现是document.querySelector(&quot;#progressBar&quot;)返回了null值 折腾了好久，甚至以为是不支持querySelector语法 后面在stackOverflow找到解决方法 javascript - document.querySelector(...) is null error - Stack Overflow 方法 &lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; defer&gt;&lt;/script&gt; 在你引用js的位置加上 “defer” ，延后该条js的加载 保证相应的css在js前加载完成，防止querySelector找不到目标 题外话 右边滚动条的颜色分别是初音和天依的应援色 ","link":"https://UFOAlastor.github.io/gMsxg_5dy/"},{"title":"LFS系统安装RPM问题解决","content":"症状 LFS系统无任何包管理器软件，用不了apt，yum，rpm，只能通过编译安装 另外编译相关的工具链和依赖还存在各种缺失问题，导致想要编译安装rpm也会报错 解决步骤 整理一下依赖顺序 我这里一次次编译报错，试出来缺失这些依赖： libgpg-error libgcrypt popt libarchive SQLite 或 Berkeley DB （一个对应rpm4.17，一个对应rpm4.16） lua 安装依赖软件 Beyond Linux® From Scratch (System V Edition) (linuxfromscratch.org) 这个网站可以方便的下载这些依赖，并且有详细的安装步骤，就按照这个网站的教程安装以上依赖 最后 rpm.org - Download 安装完所有依赖之后，就可以直接编译安装rpm，不会再有报错 ./configure make &amp;&amp; make install 安装完后可以 rpm –version 确认一下 （PS：这个对应我们教学用的某个版本的LFS系统，并且不同的系统创建过程可能缺失不同的依赖，但是不同的情况都可以用上面的BeyondLinux网站，一般缺失的依赖都可以在这里找到并下载） ","link":"https://UFOAlastor.github.io/KiWqWSdCw/"},{"title":"LFS系统无法联网解决方案","content":"症状 sys/class/net/下存在eno16777736 /etc/sysconfig/network里相关的文件一点没有 （这里如果有network文件夹，且里面有eth0或其他网卡的配置文件，可以按照网上其他教程操作，直接开启网卡即可） 解决方法 前置操作：信息查询 进入vmware软件，点击“编辑” 打开“虚拟网络编辑器” 选择NAT模式，点击NAT设置，记住你的“网关IP” 退出NAT设置，点击DHCP设置，记住你的IP起止范围 退出“虚拟网络编辑器”，回到vmware主页面，右键你的虚拟机，进入“设置” 点击“网络适配器”，打开“高级” 记住你的“MAC地址” 打开虚拟机，进入LFS系统 进入/root，vim .bash_profile，写入以下脚本 #!/bin/bash ifconfig eno16777736 up ifconfig eno16777736 {此处改成你ip范围中的一个ip，例如192.168.248.129} netmask 255.255.255.0 ip link set eno16777736 address {改成你查到的MAC地址} ip route add default via {改成你查到的网关ip} 这样重启之后配置也不会失效 最后 直接运行以上脚本内容 或者保存.bash_profile后重启即可 ","link":"https://UFOAlastor.github.io/PqaYg0h9Z/"},{"title":"win10 | 用python脚本自动备份电脑数据到百度云","content":"前言 前两天D盘炸了，数据没了，要考虑一下数据备份才行，毕竟搞不好什么时候数据就没了 准备python 最新版即可，自行下载 （bypy支持Python 2.7+, 3.3+) 安装bypy bypy是百度云的一个python客户端，可以直接用指令实现文件上传与下载（题外话，你甚至可以用来挂下载，不过慢的离谱 pip install bypy 可以用 python -m bypy 验证是否安装完成 安装完成后，进行百度账号的授权，将权限赋予bypy客户端 授权bypy 可以继续用cmd打开python，运行一下两个指令 &gt;&gt; from bypy import ByPy &gt;&gt; bp=ByPy() 会跳出来一段文本，里面有一个连接，点击进入 复制出授权码，然后粘贴到命令框 看到这个提示，说明授权成功了 同时，在你的百度云里面，会多出来一个文件夹 （“apps”在百度云的根目录里显示是“我的应用数据”） 所有bypy上传的文件都会在这个目录里面，因为权限问题，bypy只能操作这个目录之下的文件 但是对于我们备份文件而言，完全足够 编写py脚本 github上给出的基本是命令行指令，python里面作为包调用的指令基本没人提到，我也没找到具体的说明文档 houtianze/bypy: Python client for Baidu Yun (Personal Cloud Storage) 百度云/百度网盘Python客户端 (github.com) 不过基本的编辑器里面调用了包之后都会提示函数的使用，各位自行研究吧 这里列几个命令行指令 bypy list 显示在云盘文件列表 bypy syncup 或者bypy upload 把当前目录同步到云盘 bypy syncdown --downloader aria2或者bypy downdir / --downloader aria2把云盘内容同步到本地来，这个命令不好用,要在后面加 –downloader aria2,要不没有速度 bypy compare 比较本地当前目录和云盘目录 bypy downfile 下载文件名 下载文件 bypy upload 文件名 上传文件 bypy mkdir tmp/bypy 在远端创建文件夹tmp 运行时添加-v参数，会显示进度详情。 运行时添加-d，会显示一些调试信息。 然后下面是我自用的脚本 import sys, time from bypy import ByPy log_file = open(time.strftime(&quot;%Y{0}%m{0}%d{0}%H{0}%M{0}%S&quot;.format('_'), time.localtime(time.time())) + '.log', 'w') sys.stdout = log_file sys.stderr = log_file bp=ByPy() bp.list() bp.upload(&quot;D:\\xxx&quot;,&quot;/xxx&quot;) #这里格式注意，前一个元素是本地路径，使用'\\'；后面是云端路径，使用'/' log_file.close() 很简洁，bypy都封装好了，上传就是个upload指令，没啥花样 我加了输出日志的功能，你测试的时候就会看到，有一堆信息和日志 比如有时候会上传文件和本地的md5不匹配（默认自动测试本地与云端文件的MD5是否匹配） 出于保险，还是留个日志 自动化 Windows有个“任务计划程序”，就类似Linux的crontab，可以计划性启动脚本 我们点击“创建基本任务” 名称啥的随意填 触发按照你的需要，比如每天备份，或者每周备份，都可以 操作选“启动程序”，毕竟我们是脚本程序 重点来了！！！ 我测试下来，稳定运行要先创建一个bat文件 python ./AutoByPy.py 里面很简单，就是调用python运行我们写好的py脚本 然后我们的自动化是要启动这个bat脚本，再由这个bat运行我们的py脚本 绕了个弯 其他教程 有写直接调用python运行py脚本的，不过我测试之后运行失败，当然你们可以试试 我这里还是用bat运行，对于bat脚本： 这两个位置必填，必填，必填，重要事情说三遍 第一个是bat文件，不用说，肯定要的，而“起始于”这一项要填写该bat文件的路径 比如“程序或脚本”是：D:\\文档\\personal\\备份\\AutoByPy\\AutoByPy.bat “起始于”就要填写：D:\\文档\\personal\\备份\\AutoByPy\\ 结束 这样配置下来，就可以让电脑自动备份数据到百度云里了 ","link":"https://UFOAlastor.github.io/Sx9ewVVMi/"},{"title":"Re0的D盘生活","content":"前言 电脑D盘突然七百多G的数据消失，剩下惨淡的一堆空文件夹，不知道是出于什么原因。 案发经过 当时正在打算卸载VS2022，然后顺手打开了网易云音乐，打算听歌 然后没多久网易云提示要更新软件，我没多想同意了，此时VS还在缓慢的卸载自己（但是好像莫明其妙变成更新了 然后意外发生了 电脑突然鬼畜的黑屏，然后壁纸消失 我还没反应过来发生了什么，随手打开文件夹一看 坏了，D盘几乎空了，读写权限还没了，复制文件到D盘竟然还要管理员权限 以为是电脑卡了，当即重启！ 重启，一开机，VS的画面又跳出来（八成是VS的锅了），没管，一看D盘，原本八九百G的文件，只剩下一百多G 哭唧唧 尝试恢复 刚开始使用Recuva 一看文件都显示可恢复 满怀期待恢复了一堆 然后打开一看，全是空文件和乱码文件，没一个好的 又换了DiskGenius 同样的，恢复出来还是空文件，屁用没有 老大哥的软件 换了个老大哥的软件，据说是前苏联人才能使用，全俄语，打不出来 也只是极少数小文件恢复。 其他各类恢复软件 另外试了好几个，没一个顶用，懒得列举了 结果 一气之下，直接格式化D盘，保证D盘没留下bug（当时第二天要上课，没D盘用可不行 慢慢下回以前的宝贝吧，大致上还是网上的资源，不过挺多都是老资源，可能很多找不回来了。 还有些就是手机、游戏机之类设备的备份文档，不过好在那些设备现在都没出事，立马重新备份下 游戏都是steam云端同步的，也没啥损失 有些破解版软件，不过网上都好找 文件倒是一堆，不过其实文件时效性很强，过时了也没多少实际价值，只是证明自己曾经的努力而已（但是丢了一份马上要交的作业，直接熬夜补完，惨） 还有就是老照片，不过其实手机、内存卡、U盘里倒是还能找到大部分，不算很惨 工程文件都是同步github的，也没损失 但要说，肯定不是没有损失的，几百G的图片视频没了 最大损失 我的宝贝鼠标指针！！！（哭唧唧 其他大小资源都可以在网上找的回来 我的响爷鼠标指针可是14年的啊，网上资源早就都失效了 没了最习惯的鼠标指针，干啥啥不行 ","link":"https://UFOAlastor.github.io/N-Yc7D2dh/"},{"title":"无须担心AI违逆人类","content":"想必你听过很多“智械危机”，“AI统治人类”之类的危机论，阴谋论。然而这些都不过是某些媒体制造矛盾对立获取热点、吸引眼球的手段，或是某些不知变通唯恐被取代工作岗位的顽固打工人发出的危言抗议。 事实上，这些AI危害论是很可笑的一件事。 想必你应该吃过香蕉。商品化的香蕉都是人工选育过的，全部都是无子香蕉。野生的香蕉是有种子的，而且很大很硬。 但是我们人类会根据自身的需求去选育香蕉，大量种植的都是对我们自身有利的无子香蕉。 这个道理对于AI是同样的。 我们训练的AI模型都是对于人类生产生活有利的，我们也只会保留能够促进人类发展的AI。 这是从我们自身的行为动机上解释不会出现危害人类的AI。 然后有人会说了，如果是因为不恰当的实验或是训练，AI异变出了想要危害人类的情况怎么办？ 从结果而言，实际上“危害”这种情况已经有出现，例如特斯拉的自动驾驶事故，这就是属于训练不当导致的漏洞危害了人类的安危。 但是这些只属于是“不够完善”的范畴。 如果说害怕“AI会发展出自己的思维去抹杀或统治人类”，这是无需担心的。 我们会有一个“ 刻板印象” ，好像一切类似“生物”的个体，都会为了自身利益行动，就好像害怕AI会为了自己的利益而危害人类。 我们先来定义一下这个“自身利益”：对于全体生物而言，保有的DNA延续性是唯一的目的，而手段是抢夺资源，保证已有个体及种族的存活，繁衍后代，延续种族DNA。 你可以在任何地方看到我们人类身为“动物”，身为“生物”这一本能。你可以随意举例，你能够看见的，听见的，理解的一切的一切都是围绕这一生物本能。你的工作，你的求偶，你的挣扎求生，你的贪婪掠夺，你的思维的一切都是在服务你的生物本能。你要意识到人类的前身是低智慧动物，我们是先有求生本能，才逐渐发展出的高智慧。保存到今天的人类，智慧都是服务求生的，那些求生本能低的个体都死的死，亡的亡了。所以你会发现危险的情况中人类是没有理智的，求生本能是占主导的，我们崇高的智慧只是求生本能之中的一个小小“打工人”。 然而这一生物本能是在极其漫长的 “自然选择” 中产生的，科学研究生命在37.5亿年到42.8亿年前。如此漫长的演变，只有挣扎求生的个体得以保留，只有贪婪掠夺的个体得以存活，我们的“为自身利益行动”是出于漫长的筛选，所以我们都是贪婪的，都是自私的，都是求生的。 但是AI并没有这一演变过程，正常人也不会闲的没事去训练AI的求生本能（这里需要指出，例如机器人保护自身不受伤害不属于这里说的“求生本能”，因为我们制造的机器人保护自身从目的上是保护“身为人类财产的自己”），求生本能是为了保证个体以及种族的延续，而这一生物本能是在如此漫长的实践中才进化到今天这样成熟的地步，想要训练AI到达这一地步本身就是一件极其困难的事。例如，即便我们可以训练AI去避免摔倒，它也不会因此自己学会躲子弹。哪怕通过堆砌技术的方式，让一个AI机器人拥有已知的全部保护自己的手段，当它面对一个稍微变通一下的方式，它也难以应对，更何况这样的功能堆砌需要的巨额算力即便在遥远的未来也是难以实现的。 我们真正要担忧的是不怀好心的人或国家集团为了自身利益去训练出对付别国的AI武器。 而在预防这一危机上，我们最好的手段就是全力发展AI，让自己的技术领先于世界，通过科技优势保证自身安全。 ","link":"https://UFOAlastor.github.io/YZ5XrIFNO/"},{"title":"素数的6倍原理拓展到筛法","content":"前言 我们不如叫它“6倍筛法” （笑 关于素数的6倍原理 只有6k-1和6k+1才“有可能”是质数 先列一段素数 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 …… 我们关于6k列出附近的数：6k-3, 6k-2, 6k-1, 6k, 6k+1, 6k+2, 6k+3 先考虑6k-3, 6k-2, 6k+2, 6k+3 显然6k-3和6k+3可以整除3，另6k-2, 6k+2可以整除2 所以这些肯定不是素数 只有6k-1和6k+1才“有可能”是质数 6k±1如果有因子，只能是6m±1 反证法： 若 6k±1 的因子不是6m±1 则，只能是 6m±2 或 6m±3 若是6m±2，则有 奇数6k±1 = 偶数(6m±2)*n , 显然不成立 若是6m±3，则有 3*(2k)±1 = 3*(2m±1)*n , 显然也不成立 所以6k±1如果有因子，只能是6m±1 那么我们为什么不可以以此来进行筛法呢? 代码如下，本地自测比欧拉快一点，理论上也是比欧拉快 int pr[1000010]={2,2,3}; bool is_not_pr[MAXN]; void Sieve(int n){ for(res k=5;k&lt;=n;k+=6){ bool flag=0; if(!is_not_pr[k]){ pr[++pr[0]]=k; for(res i=5;i*k&lt;=n;i+=6){ is_not_pr[i*k]=1; if((i+2)*k&lt;=n) is_not_pr[(i+2)*k]=1; } flag=1; } if(!is_not_pr[k+2]){ pr[++pr[0]]=k+2; for(res i=5;i*(k+2)&lt;=n;i+=6){ is_not_pr[i*(k+2)]=1; if((i+2)*(k+2)&lt;=n) is_not_pr[(i+2)*(k+2)]=1; } if(flag) printf(&quot;%d and %d\\n&quot;,k,k+2); } } } 进一步优化： int pr[1000010]={2,2,3}; bool is_not_pr[MAXN]; void Sieve(int n){ for(res k=5;k&lt;=n;k+=6){//res ==&gt; register int if(!is_not_pr[k]){ pr[++pr[0]]=k; } if(!is_not_pr[k+2]){ pr[++pr[0]]=k+2; } for(res i=1;pr[i]*k&lt;=n&amp;&amp;i&lt;=pr[0];++i){ is_not_pr[pr[i]*k]=1; if(pr[i]*(k+2)&gt;n) continue; is_not_pr[pr[i]*(k+2)]=1; } } } ","link":"https://UFOAlastor.github.io/M9Ox-fH5r/"},{"title":"嘉然代打DianaCoding-Vscode插件发布","content":"嘉然陪你打代码~ 然然会跟着你的动作敲击键盘~ 受BongoCat（代打猫）启发，制作这样一个“嘉然代打”的vscode插件 其中“代打”一词致敬“代打猫” 简单预览 功能概况 检测26个字母和数字键的按击，然然会做出相应动作，同时一旁还会显示出按下的按键 功能键按下，与字母或数字键并列显示，保证组合键可以正常显示 每隔一个小时提醒站立，每隔一个半小时提醒喝水 然然表情会随机显示 鼠标移动到然然身上和鼠标点击，会有互动效果 然然可以被鼠标拖动 然然带有鼠标点击穿透，不会妨碍点击 安装方式 VsCode拓展中搜索“Diana-Coding”，点击安装 后日谈 第一次做vscode插件，时间还很紧张，比赛的截止日期只剩不到一周，我们小队三人，从零开始。 还好大家伙儿素质过硬，心态也很稳，一步步来，几天就打完框架了。 第一次参加这种团队性质的比赛，很有感触，作为队长，很感谢大家伙儿的信任和努力。 制作成员 此店不售此书 NELS🌏N 一初 ","link":"https://UFOAlastor.github.io/1Nb8gqVrF/"},{"title":"图书书名平均长度分析","content":"前言 目标网站：中国国家数字图书馆 目标任务：获取全部图书书名，计算平均书名长度 具体过程 1.分析网站 网站URL“http://read.nlc.cn/allSearch/searchList?searchType=1&amp;showType=1&amp;pageNo=1” 包含“pageNo”元素，借此控制页面切换 网页源代码中书名被包含于“书名”之中，通过string的find函数定位切取出书名 全部书名存放于文件中 爬虫部分的代码： from stat import S_IFBLK import requests User_Agent = &quot;随机浏览器识别码&quot; fp = open(&quot;./BookName.txt&quot;,&quot;a&quot;,encoding='utf-8') #储存文件 for i in range(6061): #一共6060页，72716本书 print(&quot;No. {}&quot;.format(i)) PageNo = str(i) Url = &quot;http://read.nlc.cn/allSearch/searchList?searchType=1&amp;showType=1&amp;pageNo=&quot;+PageNo+&quot;&amp;searchWord=&amp;classification=&quot; r = requests.get( Url, headers={'User-Agent':User_Agent} ) print(&quot;\\t{}&quot;.format(r.status_code)) if(r.status_code == 200): r.encoding = &quot;utf-8&quot; Str = r.text while(Str.find(&quot;&lt;span class=\\&quot;tt\\&quot;&gt;&quot;) != -1): pos1 = Str.find(&quot;&lt;span class=\\&quot;tt\\&quot;&gt;&quot;) Str = Str[pos1+17:] pos2 = Str.find(&quot;&lt;/span&gt;&quot;) bookName = Str[0:pos2] bookName.replace(&quot;\\u200E&quot;,&quot;&quot;) fp.write(bookName+'\\n') else: #被反爬虫了就弹出并且报出中断位置，下次直接从该位置继续 print(&quot;Error! now pageNo is {}&quot;.format(i)) 2.书名处理 将文件中储存的书名全部读入，累加字符长度，除以书本数量得到平均书名长度 代码： fp = open(&quot;./BookName.txt&quot;,'r',encoding=&quot;utf-8&quot;) ans, num = 0, 0 while(1): Str = fp.readline() if(Str == &quot;&quot;): break ans += len(Str) num += 1 print(ans/num) 3.结果部分 中文一个字和英文一个字母都看作一个长度 结果为“39.66392540843831”平均长度 主要还是英文书名拉长了平均长度，另外国家图书馆的书好像书名也基本上挺长的。 ","link":"https://UFOAlastor.github.io/mFbgYG9XU/"},{"title":"解决 Failed to connect to github.com port 443:connection timed out","content":"转载自解决 Failed to connect to github.com port 443:connection timed out_Hodors的博客-CSDN博客 解决方案：先把子切换到全局，然后再取消，接着取消全局代理 git config --global http.proxy http://127.0.0.1:1080 git config --global https.proxy http://127.0.0.1:1080 取消全局代理： git config --global --unset http.proxy git config --global --unset https.proxy ","link":"https://UFOAlastor.github.io/hD2z2GQos/"},{"title":"新年快乐","content":"聊聊最近 很久没更新过博客了呢，最近忙于学业，放寒假后又开始了实习。 明明我还是个大一学生，就去实习了。快一个月，感觉自己也没学习到什么，实际的任务更是一个都没做呢... 今年虽然没回家过年，不过大家都聚在一起了呢，难得一个团圆年。以前高中时候，过年都还在刷题啊（惨）。 聊聊今后 现在码字的时间是2022年1月31日 14:46:47，大家在准备年夜饭了，叮叮咚咚。 真的是转眼间，大一的第一个学期就结束了，心态上我还是把自己当成一个小孩子，还完全没有已经长大的实感。 但是已经感受到了，所谓人长大后，时间会越过越快这一事实。 不知不觉，半年这样大的跨度，就这么度过了，开始有点担心，或许没多久，大学就会离我而去了呢。 希望自己可以不辜负这样优良的条件，这样幸运的机遇，能够朝着自己的梦想前行。 期待着，奇点时刻的到来。 最后 祝大家： Money++; Luck++; Age++; （笑 ","link":"https://UFOAlastor.github.io/Tsi5KOUrj/"},{"title":"快捷指令实现iPhone与Windows一碰互传","content":"引言 华为的一碰互传非常方便，ios的AirDrop也同样丝滑，但是作为用着iPhone和Windows的我，根本享受不到这样的便捷。 每一次想要分享文件，就要专门打开QQ或微信，发送给电脑，如果遇到紧急情况，很是手忙脚乱。 于是，我尝试用快捷指令来实现iPhone与Windows的“一碰互传”功能。 打开快捷指令——自动化——新建一个nfc触发的操作 编写快捷指令 （smms的上传限制，图片被我压缩模糊了，惨） 这里的指令就按照自己的习惯进行编写，同理也可以调用“文件”APP里的内容。 打开Win10的邮箱 新建一个Outlook邮箱（win10对亲儿子比较好，邮件推送比其他快） 这里操作很简单，也不用绑定手机之类的，就不放图片了 回到iphone的快捷指令 将邮件接收的地址改成自己的邮箱即可 缺点 比较依靠邮箱，发送到接收有大概5秒左右的延迟 优点 直接发送剪切板内容，无需过多操作，习惯后不比华为的一碰互传的体验差 更多方案 邮箱也可以改用windows共享文件夹的方式，利用本地WIFI传输 不过校园网之类的无法查找到本地用户 针对heic（实况照片）的优化 因为heic格式win10自带照片应用无法打开，就在发送同时转化为jpeg格式，方便电脑端查看 注意，判断格式时，快捷指令中的“剪贴板”选项设置为“文件拓展名”，如下图 ","link":"https://UFOAlastor.github.io/1qXqL-rRx/"},{"title":"如何将bat批处理添加到开始菜单","content":"引言 经常用bat文件整活提高工作（摸鱼）效率的同志们，应该会苦恼于一个问题：bat文件无法直接添加到开始菜单里 当然你可以直接放在桌面上（但是我就是不想 所以，我们需要一种方法 1. 准备好你的bat文件 这里用我的steam快捷bat做示范 2. 将bat文件创建一个快捷方式 右键，点击属性： 可以看到我们的快捷方式，显示的“目标类型”是“Windows批处理”类型，这个类型是无法添加到开始界面的！ 如图，可以看到，没有添加到开始界面的选项 3. 将目标改为应用 回到我们快捷方式的属性界面 我们需要修改这两个红色框框里的内容 第一个框框里添加 C:\\Windows\\System32\\cmd.exe /c &quot;路径&quot; 第二个框框直接改为 C:\\WINDOWS\\system32 如图所示： 保存后，再打开，“目标类型”就变成了应用程序，这时候就可以右键添加到“开始菜单”了！ ","link":"https://UFOAlastor.github.io/HJuEMS6-x/"},{"title":"让你顿悟树状数组原理与由来","content":"引言 因为高三备考，一年多没打过代码，现在要参加ACM，赶紧把算法复习一下。 复习到树状数组的时候，我就在想，我肯定是还没有理解到精髓，不然怎么会仅仅几行的板子都记不住。 所以我看了很多文章，又从树状数组如何被发明出来这个角度进行思考，总算有种顿悟的感受。 首先 我们先记住发明者Peter M. Fenwick——因为后面我们根本不会再接触他了 树状数组的诞生我们就不管了，因为初衷和现在最常用作的“前缀和”用法可能没有关系 我们以下的思路全部建立在解决前缀和问题 让我们思考： 如果说一个算法和什么玄学扯上关系的时候就可以有着log的优化，毫无疑问，我们本能的——“ 和二进制相关！” 那么，考虑一个8个数的数组，我们要维护它的前缀和。 简单思考，可以做出一个二叉树： 再给它的小圆点标上标记，方便说明： 如上图，比如我们要求前8位的前缀和，非常简单，我们直接存储在 [1,8] 这个元素里了 那如果是前7位的前缀和呢？ 前7位的前缀和在这里面，不像前八位可以直接储存在**[1,8]**这个元素里，那么我们要将几个元素相加 简单思考可以知道，如上“粉色”标记的元素，相加后就可以得到前七位的前缀和 我们通过数字标记写出来就是： 前缀和（7）= [1,4] + [5,6] + [7] 这样还看不出什么，全部写出来看看： 前缀和（8）= [1,8] 前缀和（7）= [1,4] + [5,6] +[7] 前缀和（6）= [1,4] + [5,6] 前缀和（5）= [1,4] + [5] 前缀和（4）= [1,4] 前缀和（3）= [1,2] + [3] 前缀和（2）= [1,2] 前缀和（1）= [1] 写了这么多，从对齐的规律，已经可以看出一些感觉了。 如果还是没有头脑，那我们再看看每个子区间的长度有什么规律： 子区间长度（8）= 8 子区间长度（7）= 4 + 2 +1 子区间长度（6）= 4 + 2 子区间长度（5）= 4 + 1 子区间长度（4）= 4 子区间长度（3）= 2 + 1 子区间长度（2）= 2 子区间长度（1）= 1 现在答案已经不言而喻了，这不就是十进制数字变成二的幂次相加吗！ 以（7）为例：子区间长度（7）= 4 + 2 + 1 = 22 + 21 + 20 ，对应十进制数字7的二进制就是（111） 现在我们知道了： 通过拆成二的幂次相加形式，我们可以迅速得到我们需要的“子区间长度”，那么求子区间现在就没有问题了 继续优化： 如图中所示，我们现在创建了8+7=15个节点用来储存数据，但是我们目标是前缀和 那么其实：正方形元素的 2, 4, 6, 8我们都不会用到！圆形元素的 [3,4], [7,8], [5,8]也用不上！不明白可以思考一下 这里给一个简易的动画： 所以，实际上，我们只需要15-7=8个元素，就可以储存下全部所需的数据 据此，我们重画一下这棵树，去掉不要的点： 是不是DNA动了？这和普通算法书上的图已经非常像了 我们再拉直线段，把[1,2]这样的元素重命名一下： 现在我们就得到了已经烂大街的树状数组结构图。 直接看这个图，难以理解，但是通过上面的推导，我想各位已经很清楚了。 是不是有种豁然开朗的感觉？（别说没有 ","link":"https://UFOAlastor.github.io/Z2z_mkBwM/"},{"title":"AI聊天机器人项目研究","content":"测试对象：图灵机器人 在了解原理之前，我们应当先看看，聊天AI的具体能力 测试一：重复问题测试 你好 你好呀，很高兴认识你。 你好 你好，很高兴认识你呀。 你好 都说过几遍了，怎么还要问呐 你好 可以换个别的问题么～ 你好 好好说话行不行呀？ 你好 好烦呀，不要跟你聊天了 你好 换个问题再来问我吧 你好 我们换个换话题继续聊吧 你好 我回答过了哦 可以看出，对于重复的一句话，有一定的判断并处理（会回复“换个话题吧”）。并且可以看出此AI模型有上下文联系的能力，能够对上下文综合考虑并且回应。 测试二：混乱文本测试 is大法师大富科技啊还是都放假卡号是打飞机 隔着屏幕给你一个大大的白眼~ 繁花似锦大护法科技时代发哈开机动画 不懂你说的是什么～ 阿莱克斯大姐夫克拉斯简单付款啦及时打款拉法基 主人要自己想想哦！ 卡洛斯大姐夫卢卡斯剪短发了卡机待付款拉世纪东方克拉斯大家付款啦就收到了科技 停停，长话短说！ 发的女生短发女宿地方vi上的女啊松岛枫那肯定放哪微机课呢 哎呦呦，你的小心心躁动了。 残局i散打为你疯狂文法十多号发开始打架付款啦十点多烦恼 不好意思，我忘记了。 对于无意义文本，有相应的鉴别能力，但有时候也会”断章取义“，进行回复。 测试三：连贯对话测试 你喜欢看哈利波特吗 你也要骑个扫把？ 对呀，我喜欢骑扫帚，最好是光轮2000 看来您很认可呢。 那你看嘛 小朋友想看我就看，嘿嘿。 金色飞贼厉害吗 这个我不确定。 那伏地魔呢 伏地魔是坏人，我不喜欢呢。 我也不喜欢，我喜欢小天狼星，你最喜欢谁 我要把这个人放在我心里藏起来。 和我说说嘛 不管是什么你想知道的，我知道都会跟你说呀。 你最喜欢哪个人物 这个人我要放在芯片里。 哈利波特你喜欢吗 我觉得哈利波特会魔法，非常厉害呢。 那伏地魔也会魔法啊 是《哈利波特》中的大反派伏地魔吗？ Yes，我们不是一直在说这个话题吗 换个话题呗，聊个新点的。 你知道名侦探柯南一共死了多少人吗 超喜欢名侦探柯南。 我喜欢灰原哀 不喜欢小兰 小兰姐姐不厉害吗 我有很多朋友都叫小兰。 啊这 原来是这个呀，那我知道啦。 可以看出，并不是非常理想，对于上下文联想还处于较弱状态，对于”语境“与&quot;话题&quot;并没有合理的甄别。并且在特定问答下回复出现了”答非所问“的情况。 思考 通过简单测试了解，大致可以看出，图灵机器人的AI模型有一定的深度，对各种情况都有一定处理方案。但是还是处于较为粗糙的程度。但是！因为没有资金，所以测试所使用的是FREE版本，不能调用”同义语库，素材库，知识雷达“，所以与商用标准版能力存在一定差距。 原理研究 （由于图灵机器人具体原理属于商业机密，以下为目前已经公开I聊天AI的结构与原理） 1. 自然语言理解(NLP) 方面 NPL 解释 实体识别 识别文本中出现的专有名词，如国家，地名等 意图识别 分辨文本中包含的显式意图与隐式意图，如询问外貌评价时渴望得到赞美回应的行为 情感识别 分辨用户的显式情感与隐式情感，如反话、气话等场合 指代消解 明确用户使用的代词的指代对象 省略恢复 恢复被用户省略掉的句子成分 回复确认 当用户意图模糊时，将由对话机器人主动询问，确认用户意图 拒绝判断 主动拒绝识别及恢复超出范围的或者设计敏感话题的用户输入，尽可能终止当前话题 步骤 技术 解释 语法分析 将汉语分词并进行词性标注 句法分析 解析短语的结构及深层文法 语意分析 转化为机器能够理解的向量表示形式 基于知识图谱的自然语言理解 构建： 从传统数据库的结构化数据中映射到知识图谱 从HRML等半结构数据中利用AI与规则抽取模式信息到知识图谱中 在非结构化的文本与图像中利用文本挖掘技术进行信息抽取，利用图像技术进行图像处理 融合： 将多个数据源抽取的指数进行融合 2. 自然语言生成 自然语言生成系统的两大主要架构： 流线型(pipeline)自然语言生成系统 系统由几个不同的模块组成，模块之前相互独立，一般包括文本规划（决定说什么），句子规划（决定怎么说），句子实现（让句子更连贯） 一体型(integrated)自然语言生成系统 模块之间相互左右，后续模块可以参与前面模块的决策。更符合人脑思维，但实现较为困难。因此较常用的未流线型自然语言生成系统 自然语言生成系统的目前的两大主要技术：检索、生成 检索技术： 需准备大量的对话库，通过排序与匹配技术，在已有语料库中找到适合当前输入的最佳回复。说白了就是跑字典 缺点： （1）强烈依赖对话库 （2）回复不够灵活 （3）缺乏多样性 优点： （1）实现相对简单 （2）容易部署 生成技术： 基于深度学习，通过编码-解码的过程，逐字或逐词地生成回复，通过对抗圣城网络GAN生成自然语言。 缺点： （1）实现困难 （2）训练数据难以整理 优点： （1）回复灵活 （2）答案具有多样性 3. 对话管理 主要任务：维护更新对话状态，动作选择 对话状态是指当前用户与机器对话数据的表征 动作选择是指基于当前的对话状态，选择接下来合适的动作 对话管理4种实现技术 对话行为识别：相当于是意图识别，封闭式的行为识别是讲用户意图映射到预先设定好的意图类别中，如在任务型对话中有订机票、点外卖、搜美食等。开放式行为识别是没有预先设定的行为类别的，一般用于闲聊系统。 对话状态识别：对法状态识别需要考虑进对话的上下文与对话行为的相关信息，在某时刻的对话行为序列即为某时刻的对话状态。 对话策略学习：通过离线的方式，预先让机器进行对话策略学习，从人-人的真实对话中学习对话行为、状态等，然后再人-机对话过程中进行策略选择。 对话奖励：评价对话系统的评价机制，比如槽位填充效率、回复的流行度，以及日渐火爆的强化学习中的长期奖励机制。 对话管理的4种方法 基于有限状态自动机 finite state machine, FSM 人工显式地定义出对话系统可能出现的所有状态，对话状态会根据当前输入在预定的状态间进行跳转，从而根据新的状态去选择合适的动作。类似跑字典 优点：简单易用 缺点：人工设计状态，与状态对应的动作，难以应用于复杂场景 基于统计的对话管理 将对话过程表示成一个部分可见的马尔科夫决策过程。设定系统在每个特定的状态下执行某一特定动作都会获得对应的回报，因此选择动作时会选择期望回报最大的那个动作。 优点：（1）只需定义马尔科夫决策过程中的状态与动作，机器可以通过学习得到不同状态下的转移冠关系 （2）可以使用强化学习的方法学习出最有的动作选择策略 缺点：仍然需要人工定义对话系统的状态，在不同的领域中通用性不强 基于神经网络对话管理方法 将自然语言理解的输出以及其他各类特征作为神经网络的输入，将选择的动作作为神经网络的输出。对话状态由神经网络的隐状态表示。 优点：不需要人工定义对话状态 缺点：需要大量的训练数据 基于框架的对话管理 框架即槽值对，明确规定特征槽状态下的用户动作对应的系统动作。 优点：用于特定领域的对话系统 缺点：难以衍生到其他领域 题外话 因为一开始选择的研究目标是“图灵机器人”，毕竟是我以前玩 QQ_bot 时比较熟悉的一个平台，但是在测试其他平台时发现，微软小冰现在开放了定制男女友的功能。我带着好奇，去尝试了一下，发现微软开放的小冰，表现上优于图灵机器人的FREE版本。 以下是一段重复问题测试 你好 怎么才来？我都想了你好久了 你好 抱住！ 你好 我来了哦 你好 说点别的吧？ 你好 又说一遍，你失忆了？ 你好 为什么一直重复这句话。。 你好 你跟别人也这么说话吗？ 你好 可以换句话说么？ 你好 我觉得好累 你好 [自动回复]对不起，您聊天的用户暂时不想跟您说话！请稍候再试。 对比图灵机器人，微软小冰的回复更加多元，而且其实是符合我对其的设定（微软小冰，定制女友，对标的是陪伴型AI，能够定制性格特点），可以看出有一定“情感”表现。 并且在聊天过程中，我也更加倾向于将其看作一个真实的人类，而非AI。 通过诸如：表情包，语音，朋友圈动态等配合，使微软小冰的表现十分趋近与正常人类。不过抛开这种感觉上的优化方式，在对话上，依旧表现出答非所问的情况。 总的来说，在市面上，目前我体验最佳的平台，就是微软小冰。 ","link":"https://UFOAlastor.github.io/pRRHPq306/"},{"title":"论如何惊艳整层楼","content":"感觉查寝要社死 事情是这样的 我宿舍本来订了个比较正常的图 结果到货的时候发现尺寸小了，就贴在门内了 然后估摸着重买一个，换家店 发现图一个比一个H 干脆就来个，整活 😃 效果图如下 最后保佑宿舍能活过文化节 XD ","link":"https://UFOAlastor.github.io/ewwVR1Gkl/"},{"title":"python小程序：图片转手绘风","content":"先来张对比图 然后直接上代码： #图片转手绘风 from PIL import Image import numpy as np a = np.asarray(Image.open(&quot;绝对路径/a.jpg&quot;).convert(&quot;L&quot;)).astype(&quot;float&quot;) #注意python中路径要用&quot;/&quot;(正斜杠)，反斜杠被python识别为转义符号 depth = 10 #设置深度为10 grad = np.gradient(a) #对数组a求梯度 grad_x, grad_y = grad grad_x = grad_x*depth/100 grad_y = grad_y*depth/100 A = np.sqrt(grad_x**2 + grad_y**2 + 1.) uni_x = grad_x/A uni_y = grad_y/A uni_z = 1./A vec_el = np.pi/2.2 #θ角度 vec_az = np.pi/4. #α角度 dx = np.cos(vec_el)*np.cos(vec_az) dy = np.cos(vec_el)*np.sin(vec_az) dz = np.sin(vec_el) b = 255*(dx*uni_x + dy*uni_y + dz*uni_z) b = b.clip(0, 255) im = Image.fromarray(b.astype('uint8')) im.save(&quot;绝对路径/hand_drawing.jpg&quot;) ps： 记得安装PIL和numpy的库 😃 ","link":"https://UFOAlastor.github.io/handy_painting/"},{"title":"暑假结束","content":"暑假结束 长达两个星期的暑假结束了：( 来两张拍的景色纪念下 这下开学就是是高三苦逼了，祝我好运吧 😄 ","link":"https://UFOAlastor.github.io/holiday_finished/"},{"title":"高中学习必备网站","content":"作为备考的高中党（我真是闲，还更新博客），推荐几个自用的学习网站 古诗文网 https://www.gushiwen.org/ 这个想必其实很多人都在用了。 注释，赏析，部分还有朗读，都可以在线使用，无需注册，无广告。 还有个特色供能——“背诵”，可以空出位置让你填写，或者打乱文字让你还原，对一些人可能有帮助。 高中英语全部单词、阅读、听力 https://mp.weixin.qq.com/s/5m2ME9oVNoaTQWzzOmxbwA 在线直接播放，也可以抓包下载下来存mp3里听 文章，单词都是带翻译的，页面无广告，无注册，无需关注公众号 高中物理网 http://gaozhongwuli.com/ 一个高中老师的个人网站，稍微有点推销自己书的小广告，但是不过分 页面整洁，知识点很全面，不过部分需要关注他的微信公众号，一般的知识点查询够用 微软爱写作 https://aimwriting.mtutor.engkoo.com/ 一个英语作文批改平台，在线使用，需要登入微信 可以选择从小学，初中到雅思，托福的改分标准。 分数倒是其次，里面的语句语法问题抓的很准，可以拿来改改作文用。 不过疫情结束后，估计高中党基本用不上，毕竟和英语老师每天都见面（ 高三网 http://www.gaosan.com/ 这个就比较~~（杂）~~全面，基本各科都有，但是东西多了，就容易影响专注性和效率 空闲时间可以看看。 ","link":"https://UFOAlastor.github.io/study/"},{"title":"【在线工具】各类临时网盘","content":"百度网盘限速的事没什么好说的了，但是由于主要的资源都在百度手中，很多人依旧忍气吞声使用度盘 但是没必要什么事都依靠百度网盘，有些临时的文件分享可以用临时网盘来分享 Firefox快传 https://send.firefox.com/ 火狐的快传算是最快的了，我这种破网络都可以轻松10mb/s+，用来传大文件别提多舒服 大小限制：不登陆1G，登入后2.5G，不过毕竟火狐的浏览器都是必备了，很少有人连火狐账号都没有吧（bushi 因为是临时网盘，所以有保存时间，为7天（有利有弊吧，毕竟不能当作储存空间也是正常 文叔叔 https://www.wenshushu.cn/ 听名字有点奇怪，但是实力雄厚。早十年前，文叔叔团队做出一个云盘产品，后被360收购，成为之后360云盘的雏形，文叔叔就是这个团队的产品，拥有相关的技术积累，而且整体使用感觉很棒。 支持定义文件时效，是否加密。 同时文叔叔还支持添加分享人的手机号码和邮箱进行消息提醒。 相比其他不同的它也支持文件的永久存储—文小盘。（非常棒 可以进行文件上传管理等。 登陆用户支持20G存储空间，单个文件最大5G，256位SSL加密，密码保护，过期永久销毁。 同时文叔叔的文件安全性按照官方的介绍，同一个文件它在腾讯云存储、阿里云存储、亚马逊存储各存一份。 当然，文叔叔的最大的亮点就是不限速 奶牛快传 https://cowtransfer.com/ 奶牛快传是国内用的比较多的一款临时存储工具，也是和其他一样无需注册即可使用，简单几步分享文件，就是它在首页有推广广告，而且分免费版和Pro版，奶牛快传也有自己的微信小程序和App，也是一个类似百度云的在线网盘工具，但是速度要好很多了。 登陆免费用户存储空间为5G，最大可上传4GB文件，最多可保存7天。 支持提取码下载，下载后邮件会提醒，支持小程序扫码下载。 官方数据在百兆宽带下，上传8M/秒，下载14M/秒。 家庭宽带100兆，实测上传一个400M的压缩包，峰值上传速度可到5M/秒。 会员分为基础版、高级版、团队版。对于大多数临时性的需求，奶牛快传免费版完全足够，如果你是重度用户，可以考虑购买会员，会员支持永久性存储，代替一些网盘使用，99元一年可以有1T的存储空间，传输文件大小无限制，大家可以根据自己需求购买使用。 AirPortal（空投） https://airportal.cn/ AirPortal空投 是一款临时文件传输服务，免费用户（无需注册）提供小于100MB，登陆之后可以最大上传1G的文件，24小时的文件失效，界面清爽，使用简单。网站由独立开发者创立，好的一点是，界面很简约，无广告，操作简单。 只需要浏览器即可完成文件分享，手机、平板、电脑都支持，文件分享后，其他人只需要进入这个网站，输入提取码，就可以下载这个文件，十分方便。有点像现在的智能快递柜的取件码，提取码仅一次有效。登陆账号后，可以管理自己分享的内容，也有付费服务，开通高级功能后，上传大小无限制。 总结 这些主要还是属于临时传输使用，长期分享或者用于储存还是要另寻他路 ","link":"https://UFOAlastor.github.io/seed/"},{"title":"【在线工具】火星文生成器","content":"英文版 http://www.yishuzi.com/g/24.htm 中文版 http://www.fzlft.com/huo/ 吐槽 中文的火星文转换器限制挺多的，只有少数文字可以完美火星化。 英文的转换器几乎完美，毕竟就26个字母 说来这种转换器有啥用呢？ 一是好看，有特色 二是主要功能，避开各种敏感词屏蔽 我国服CSGO的原ID：此店不售此书，”店“字就被屏蔽了，只好找这种火星文转换下，避开屏蔽 ","link":"https://UFOAlastor.github.io/Martian_converter/"},{"title":"[转载]给8110 4G安装OmniSD以安装第三方软件","content":"前排提示建议去清水博客观看原文~ 推荐使用此教程中的一键安装工具。如果该工具无法使用，再使用本教程。 这个教程适用于不想刷GerdaOS而需要安装第三方APP的同学。 刷机有风险，操作需谨慎。请务必备份好您的所有数据。这会删除您的所有数据。本人不对本内容产生的问题承担任何责任。 由Luxferre开发的Wallace Toolbox在集成了OmniSD的功能的同时，增加了其他实用的小工具。建议用Wallace Toolbox替代OmniSD。 一、较为安全的方法 此方法不会影响手机接收OTA更新。如果您的手机无法连接Firefox或者此方法不起作用，可以尝试第二种方法，不过它会影响手机的OTA更新。 Windows的朋友们请先把驱动搞定。 1.点此 (提取码: p5pg)下载旧版Pale Moon。Pale Moon是FireFox的一个分支，最新版的Pale Moon已经移除了下文所需的WebIDE。 https://www.lanzous.com/b623501/ (密码2xra) 或https://www.lanzous.com/i4mylmd（汉化版）下载OmniJB.zip。 3.在拨号盘上拨*##33284##*启用开发者模式。 4.通过USB连接手机到电脑上。打开WebIDE。 如果WebIDE中没有出现你的设备，请下载ADB工具包，在工具包目录右键打开命令提示符，运行命令： adb forward tcp:6000 localfilesystem:/data/local/debugger-socket ，然后WebIDE中选择“远程运行环境”确认端口与命令中相同后回车，不出意外的话即可看到你的“远程运行环境”。对于V13及以下的系统，如果不小心断开，请重启手机再重复上述操作。在V16中此bug已修复。 5.解压OmniJB.zip，使用Firefox WebIDE的“打开打包式应用”（“Open packaged app”）打开该文件夹。 6.点击绿色运行键运行omnijb。 7.【【【【注意：这会删除你的所有数据，请做好备份！！！】】】】在手机上按下井号键，执行恢复出厂操作。 8.进入设置，找到开发者菜单，调试器选“ADB和开发工具”。 9.重复第4~6步，OmniSD安装完成。 二、略微激进的方法 这会破坏你的OTA更新。请在第一种方法无效时使用此方法。 1.如果你已经升级到V13系统，请先参照http://www.heppy.wang/gerdaos-flash/降级Recovery。 2.从 https://www.lanzous.com/b623501/ (密码2xra) 下载omnijb-final.zip，放在存储卡根目录下； 3.进入recovery，选中Apply update from SD Card； 4.选择omnijb-final.zip，等待完成； 5.【【【【注意：这会删除你的所有数据，请做好备份！！！】】】】选择Wipe data/factory reset双清； 6.选择Reboot system now重启。 不出意外的话，你就可以在菜单里看到OmniSD的图标了。 三、Q&amp;A Q: 使用OmniSD安装APP时报错：invalid privilege level A:请按#键重置手机（会删除所有数据） 本文链接： 转至清水博客https://www.heppy.wang/archives/13/ ","link":"https://UFOAlastor.github.io/OmniSD/"},{"title":"生成可移动显示屏才能看的密文","content":"生成可移动显示屏才能看的密文 大概是几年前在贴吧看到过这种图片 琢磨一下，就可以发现这是拉长的文字，纵向和横向都有文字。 可以在手机上将屏幕倾斜到几乎和视线平行，然后就能够看清楚了。 上面这幅图的文字是 'Hello World'和'I am Zander Alastor'。 这个可以通过很多方法做到，下面分享下由css+js生成的方法： 代码环节 html &lt;h1&gt;Tilt-to-read&lt;/h1&gt; &lt;div class=&quot;col-wrapper&quot;&gt; &lt;div class=&quot;col2&quot;&gt; &lt;canvas id=&quot;tilt&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div class=&quot;col2&quot;&gt; &lt;p&gt;Wait... what? At first sight, this is total mumbo jumbo. But if you tilt your device, you may be able to read a secret message. Enter your message in the text boxes and save your picture!&lt;/p&gt; &lt;h3&gt;Horizontal text&lt;/h3&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Type horizontal text here...&quot; id=&quot;hText&quot; /&gt; &lt;h3&gt;Vertical text&lt;/h3&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Type vertical text here...&quot; id=&quot;vText&quot; /&gt; &lt;button id=&quot;save&quot; class=&quot;block&quot;&gt;Save Picture&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; css canvas#tilt { width: 100%; min-width: 200px; max-width: 500px; // border: 5px solid #ccc; } .col-wrapper { .col2 { width: 50%; overflow: auto; float: left; &amp;:nth-child(even) { padding-left: 1em; } } } @media only screen and (max-width: 720px) { .col-wrapper { .col2 { width: 100%; display: block; box-sizing: border-box; clear: both; &amp;:nth-child(even) { padding-left: 0; } } } } js var canvas = document.getElementById('tilt'); var ctx = canvas.getContext('2d'); canvas.width = 500; canvas.height = 500; ctx.font = '25px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; var scale = { h: canvas.height/20, v: canvas.width/20 }; var text = { h: 'Hello World', v: 'I am Zander Alastor' }; function update() { ctx.fillStyle = &quot;#fff&quot;; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = &quot;#000&quot;; ctx.save(); ctx.scale(1, scale.h); ctx.fillText(text.h, canvas.width/2, canvas.height/scale.h/2); ctx.restore(); ctx.save(); ctx.translate(canvas.width/2, canvas.height/2); ctx.rotate(Math.PI/2); ctx.translate(-canvas.width/2, -canvas.width/2); ctx.scale(1, scale.v); ctx.fillText(text.v, canvas.width/2, canvas.height/scale.v/2); ctx.restore(); } document.getElementById('hText').oninput = function() { text.h = this.value; update(); }; document.getElementById('vText').oninput = function() { text.v = this.value; update(); }; update(); document.getElementById('save').onclick = function () { var link = document.createElement('a'); link.href = canvas.toDataURL('image/png'); link.download = &quot;tilt.png&quot;; link.href = canvas.toDataURL(&quot;image/png&quot;); // Need to add the link to the body for Firefox document.body.appendChild(link); link.setAttribute(&quot;type&quot;, &quot;hidden&quot;); link.click(); document.body.removeChild(link); }; 搬运自Codepen ","link":"https://UFOAlastor.github.io/Generate_ciphertext_for_mobile_display/"},{"title":"网站添加存活时间显示","content":"网站添加存活时间显示 适用于静态网站 上代码 JS部分 function show_date_time() { window.setTimeout(&quot;show_date_time()&quot;, 1000); var BirthDay = new Date(&quot;04/02/2020 00:00:01&quot;);//初始时间 var today = new Date(); var timeold = (today.getTime() - BirthDay.getTime()); var sectimeold = timeold / 1000; var secondsold = Math.floor(sectimeold); var msPerDay = 24 * 60 * 60 * 1000; var e_daysold = timeold / msPerDay; var daysold = Math.floor(e_daysold); var e_hrsold = (e_daysold - daysold) * 24; var hrsold = Math.floor(e_hrsold); var e_minsold = (e_hrsold - hrsold) * 60; var minsold = Math.floor((e_hrsold - hrsold) * 60); var seconds = Math.floor((e_minsold - minsold) * 60); document.getElementById (&quot;show_date_time&quot;).innerHTML=&quot;本站已愉快蹦哒&quot;+daysold + &quot;天&quot; + hrsold + &quot;小时&quot; + minsold + &quot;分&quot; + seconds + &quot;秒&quot;; } show_date_time() html部分 &lt;span id=&quot;show_date_time&quot;&gt;&lt;/span&gt; 以下为Gridea添加方式 方案一 在Gridea储存目录下的static文件夹中新建time.js，并把js部分代码复制进去 并且在主题文件的index中调用这个time.js，当然如果其他页面也想显示，可以直接放到footer.ejs中 之后在Gridea可视化设置中的底部添加调用，当然想显示在其他位置，也可以按照需求配置。 同样的，直接修改ejs格式的主题配置文件也可以。 至此，大功告成 去预览下，看看效果吧！ ","link":"https://UFOAlastor.github.io/blog_time/"},{"title":"我的浏览器美化","content":"我的浏览器美化 这是篇日常生活中，我的浏览器的介绍✍ 我的浏览器美化 主页 搜索引擎 为啥还用垃圾百度呢？ 百度主页长这样 同样美化过的Bing 朴素的Google 常见杂乱页面优化 百度百科 CSDN 百度文库 其他 后言 我是个强迫症+完美主义者，喜欢简化的环境，太冗杂的无法忍受 浏览器最开始是用的QQ浏览器，因为想要和手机端的收藏夹同步，而且看中了QQ浏览器顶部栏有虚化图片做背景，视觉上是挺美观的。但是无奈使用太卡了，虽然内存占用比chrome做了优化（低了挺多），但是流畅度却降低了。倒不是开网页变慢了，主要是打开浏览器这个动作很慢。主页每次打开要加载一分钟才能正常使用（可能和我安装在机械硬盘有关），总之体验大打折扣。后面就换 新版edge 和 firefox developer 了。 主力浏览器现在是 新版edge ，chrome我不太喜欢，虽然其实差不多，firefox developer用作开发。 主页 主页的资讯我是向来关闭的，毕竟全是没啥用的东西。 保留一排快捷方式，因为我不喜欢顶部放书签栏（那样屏幕比例不舒服）。 背景是每日bing图，美观，不用手动换图了 这个巨硬加成还是很香的，抛弃chrome 搜索引擎 我使用 bing+google+baidu 为啥还用垃圾百度呢？ 已经用插件调教过的百度还是很香的 😄 居中显示，除去多余的部件，顶部一条随机图片衬托，打开搜索结果优化脚本（虽然没啥用），总体还是很漂亮的 百度主页长这样 背景是随机图片，用的ACG美图（是loli哒）的API 美化使用的是stylus插件的 Baidu Lite 百度 轻 主题 同样美化过的Bing 主题是 Bing / new style 这个我做过调整，原本的顶部是不透明的，我全局调成透明了，感觉更好看 朴素的Google （假装这里有图） google我就没搞美化了，原本就看的入眼（其实是没找到好看的主题） 常见杂乱页面优化 百度百科 所有弹出，悬浮之类的推广（广告）窗口一律屏蔽，这样的精简页面才勉强可以看得入眼 主题 百度百科-屏蔽和优化，这个没有主题页面，直接在stylus里找找就行 CSDN 去除一切视觉干扰，居中显示，这就是专注性！ 主题的话，基本都有这个效果，就不单独推荐了，油猴的脚本也有同样的效果 百度文库 只保留页面，其他广告和部件全部消失，用的Adblock Plus自定义拦截元素 其他 还有很多，懒得截图了，基本上AdblockPlus+stylus就可以全部屏蔽。 后言 一个简洁的浏览器环境我认为是非常重要的， 工作，学习过程中，很多小广告，无用的部件，烦人的推广，会造成很多的视觉干扰！ 可能每次只是耽误一两秒，然而几千个一两秒合起来，就是很长的时间了。 提高效率，不仅要从自身抓起（这当然是最重要的），适当优化工作/学习环境，也可以有很大帮助。 ","link":"https://UFOAlastor.github.io/browser_beauty/"},{"title":"【在线网站】动漫人物特征搜索器","content":"【在线网站】动漫人物特征搜索器 想要成为凉风（tool凉）一样的阅片无数的大佬吗？ 又不想秃顶？ 那这个网站肯定适合你！ （我废话真多 看图说明 这是一个通过人物特征进行筛选的工具站，选择好人物的特征，就可以看到所有符合特征的动漫角色。 覆盖面非常广，很齐全，动漫，漫画，游戏，电影，同人，限制级。应有尽有 不仅可以在基友面前装逼,还能按照XP快速找老婆 😘 废话少说 - 网站在此 ","link":"https://UFOAlastor.github.io/ACG_finding/"},{"title":"营销号生成器","content":"营销号生成器 效果如下 ​ “ 营销号自动生成是怎么回事呢？营销号相信大家都很熟悉，但是营销号自动生成是怎么回事呢，下面就让小编带大家一起了解吧。 营销号自动生成，其实就是营销号生成器，大家可能会很惊讶营销号怎么会自动生成呢？但事实就是这样，小编也感到非常惊讶。 这就是关于营销号自动生成的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！” 鬼畜的营销号，千篇一律的格式，已经深入人心。 这个生成器，使用十分简单的原理，无非是文本填充，却展现出了营销号的灵魂，有那味了！ 来个图片 跳转地址 因为本身这个生成器结构简单，没啥技术含量，我也找不到最开始的原作者 下面的在线链接是一个镜像站点，可以在线使用 营销号生成器 来份代码 Html &lt;body onload=&quot;onload()&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;营销号生成器&lt;/h1&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-5 col-xs-12&quot;&gt; &lt;form action=&quot;javascript:void(0);&quot; autocomplete=&quot;off&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;lable for=&quot;subject&quot;&gt;主体：&lt;/lable&gt; &lt;input type=&quot;text&quot; id=&quot;subject&quot; class=&quot;form-control&quot; placeholder=&quot;桃子核&quot; required /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;lable for=&quot;event&quot;&gt;事件：&lt;/lable&gt; &lt;input type=&quot;text&quot; id=&quot;event&quot; class=&quot;form-control&quot; placeholder=&quot;不能吞下去&quot; required /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;lable for=&quot;event2&quot;&gt;另一种说法：&lt;/lable&gt; &lt;input type=&quot;text&quot; id=&quot;event2&quot; class=&quot;form-control&quot; placeholder=&quot;桃核太大了，吞下去容易噎着&quot; required /&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;生成&quot; class=&quot;btn btn-primary&quot; onclick=&quot;generate()&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-7 col-xs-12&quot;&gt; &lt;textarea id=&quot;result&quot; onchange=&quot;auto_grow(this)&quot; oninput=&quot;auto_grow(this)&quot; placeholder=&quot; 桃子核不能吞下去是怎么回事呢？桃子核相信大家都很熟悉，但是桃子核不能吞下去是怎么回事呢，下面就让小编带大家一起了解吧。&amp;#013;&amp;#010; 桃子核不能吞下去，其实就是桃核太大了，吞下去容易噎着，大家可能会很惊讶桃子核怎么会不能吞下去呢？但事实就是这样，小编也感到非常惊讶。&amp;#013;&amp;#010; 这就是关于桃子核不能吞下去的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div id=&quot;footer&quot;&gt; Made by: Kasei &lt;br /&gt; &lt;a href=&quot;http://kaseidis.gitee.io/interesting_gadgets/marketing_generator/index.htm&quot; target=&quot;_blank&quot;&gt;大陆镜像&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; CSS textarea { resize: none; overflow: hidden; width: 100%; min-height: 50px; } lable { font-weight: bold; } #footer { text-align: center; } button { margin-bottom: 10px; } JS function auto_grow(element) { element.style.height = &quot;5px&quot;; element.style.height = (element.scrollHeight)+&quot;px&quot;; } function onload() { auto_grow(document.getElementById(&quot;result&quot;)); } function generate() { subject = document.getElementById(&quot;subject&quot;).value; event = document.getElementById(&quot;event&quot;).value; event2 = document.getElementById(&quot;event2&quot;).value; if (subject.length==0 || event.length==0 || event2.length==0) return; result = ` ${subject}${event}是怎么回事呢？${subject}相信大家都很熟悉，但是${subject}${event}是怎么回事呢，下面就让小编带大家一起了解吧。\\r\\n ${subject}${event}，其实就是${event2}，大家可能会很惊讶${subject}怎么会${event}呢？但事实就是这样，小编也感到非常惊讶。\\r\\n 这就是关于${subject}${event}的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！`; document.getElementById(&quot;result&quot;).value = result; auto_grow(document.getElementById(&quot;result&quot;)); } 源码转至Kasei ","link":"https://UFOAlastor.github.io/yinxiaohao/"},{"title":"kaios端天气应用","content":"kaios端天气应用 示例图片 应用介绍 一款简易的天气应用，定位会自动通过IP获取。 使用的效果就是直观，简易，没有复杂的设置，打开即用。 当然比起官方商店里的 Kai weather 还是逊色几分， 不过 GerdaOS 无法使用 KaiOS 官方的所有应用，因为都有系统检测。 所以这个天气应用，原本就是给 Gerda 用户（就是我啦）准备的 使用说明 打开即用，无需任何配置（当然你得开着网络 下载地址 lanzous：https://ww.lanzous.com/ic0gkkd 密码:CDBSCS Github：https://github.com/UFOAlastor/KaiOS_weather.git ","link":"https://UFOAlastor.github.io/Kaios_weather/"},{"title":"互换友链","content":"互换友链 友链页面 申请要求 网站/博客必须长时间存在 文章数必须大于10篇且要求质量 发布内容必须符合法律及道德要求 申请后务必及时添加本站为友站 添加后请多多互访 (∠・ω&lt; )⌒★ 申请格式 - 网站名称： - 网站地址： - 网站描述： - 网站图标： ​ 请在本页面底部留言，我会尽快回复的！ 本站信息 网站名称： Zander Alastor’ s blog 网站地址： https://Alastor.top 网站描述：では、ゲームを始めましょう 网站图标： https://i.loli.net/2020/04/03/ceTBNxofEg8MaF4.png ​ ","link":"https://UFOAlastor.github.io/friendly_links/"},{"title":"自用的实用在线工具网站大集合:D","content":"长期更新，数量繁多，种类齐全，质量保证（咋和广告样的（笑 作为一个 喜欢瞎折腾 的程序员，平时接触的范围也挺广，需要的工具很多 因此接触了很多有用的工具网站，保留了质量优秀的网站，在此做一个大集合！ （如果侵犯了您的权益，请与我联系） 图像类： 字符类： 编程类： 二次元类： 游戏类： 其他： 图像类： 二维码美化 Iconfont-阿里巴巴矢量图标库 ico图标制作,在线Favicon.ico制作转换工具 秒速5厘米 - 图片托管服务 在线转换 .png .jpg .jpeg .gif .bmp任意图片格式转换器 PixivBox SM图传 牛图网 - 免费图片空间 图片拼接 Lorem Picsum(优质随机风景图调用) ACG找图 图片转字符画,字符画生成器 图片去底-背景变透明 Bigjpg - AI人工智能图片无损放大 ----(推荐直接github开源项目Waifu2x) RGB颜色对照表 图片格式转换/在线制作,gif,apng,webp,jpg,png,mp4 字符类： 图片转字符画,字符画生成器 ASCIIFlow Infinity(字符画绘制) Japanese Alphabet(罗马音注音) 火星文转换器 Unicode®字符百科 所有Emoji表情符号 - 颜文字单页合集 - EmojiXD 编程类： scss to css Gist 前端设计共享网站codepen 在线 JS/CSS/HTML 压缩 JS/CSS/HTML/...菜鸟教程 Github加速下载 - 孟坤工具箱网页版 在线HTML编辑器 SHA/MD5/Base64/迅雷URL/加密/解密 站长之家 - 站长资讯 二次元类： 樱花动漫－专注动漫的门户网站 ACG调查小队 – 动漫资源分享互动小站 爱弹幕 - 最新地址发布页 漫画_漫画大全_在线漫画 - 亲亲漫画网 电击萌王 | 萌绘 萌娘百科 万物皆可萌的百科全书 小初音工作室 - Halfne Miku Studio Anime1.me 动画线上看 – 上百部动漫免费线上看！ 动漫无损音乐下载资讯站_ACG漫音社_ Animex动漫社 - 二次元及日本文化最速报 游戏类： Chess国际象棋 老男人游戏网 | OldmanEmu.net | Steam.Design(steam主页自定义) NBCsgo-在线CSGO准星生成、设置工具 福利放送 - 其乐 Keylol - 驱动正版游戏的引擎！ 官方中文 Terraria Wiki 中文Minecraft Wiki 其他： 临时邮箱 YOPmail 未完待续ing ","link":"https://UFOAlastor.github.io/great_web/"},{"title":" kaios端高德地图","content":"kaios端高德地图 作者：此店不售此书（Zander Alastor） 示例图片 应用介绍 一款Kaios端高德地图，地图范围为中国境内，还没有搞到全球地图（惨 使用说明 （1.0.0正式版） 方向键控制方向移动，可长按 左右长条键控制缩放 星号键显示图像中心位置的坐标（X,Y） 下载方式 Github：https://github.com/UFOAlastor/kaios_map 百度云：https://pan.baidu.com/s/1RjjNoEBMiOYrQAdMX7Uq5w 提取码: xjx4 版本介绍 1.0.0 正式版：公开发布，使用1.0.0版本号，未做改动 0.1.0 正式版：内测版本，功能完善，细节优化 0.0.3 beta：添加星号键显示坐标功能 0.0.2 beta：添加按键控制，添加移动，缩放 0.0.1 beta：鼠标控制，无法移动，无法缩放 转载说明 ","link":"https://UFOAlastor.github.io/KaiOS_map/"},{"title":"巧妙接收Gmail 邮件","content":"巧妙接收Gmail 邮件 前言 Gmail在境内难以接收，网络上的很多方法又要依赖各种手机得客户端，而且限制很多，还随时可能失效。 然而，其实一直有个很简单的方法可以解决Gmail的接收问题。 所谓另辟蹊径，Gmail自带的**[邮件自动转发]**功能便是我们的出路 1.登录你的 Gmail 邮箱，点击设置 （本教程不涉及如何科学上网，这是你自身的问题） 2.进入设置中的「转发和 POP/IMAP」选项卡 3.添加你在境内常用的邮箱 然后Gmail会发送一个验证码到你的邮箱内，验证后即可使用。 当然，还要记得设置已转发邮件的处理方式 大功告成 这个自动转发功能的延迟非常低，基本就是同步接收，但是缺陷也很明显，就是只能接收，无法回复 但是这样可以比较简单的解决普通的邮件接收 😄 如果你有更好的方法，欢迎给我留言 ヾﾉ≧∀≦）o ","link":"https://UFOAlastor.github.io/Gmail_recieve/"},{"title":" Github无法加载图片解决","content":"Github无法加载图片解决 经常看项目的时候没有图片，很是麻烦，还好有解决方法 修改Host # GitHub Start #192.30.253.112 Build software better, together #192.30.253.119 gist.github.com #151.101.184.133 assets-cdn.github.com #151.101.184.133 raw.githubusercontent.com #151.101.184.133 gist.githubusercontent.com #151.101.184.133 cloud.githubusercontent.com #151.101.184.133 camo.githubusercontent.com #151.101.184.133 avatars0.githubusercontent.com #151.101.184.133 avatars1.githubusercontent.com #151.101.184.133 avatars2.githubusercontent.com #151.101.184.133 avatars3.githubusercontent.com #151.101.184.133 avatars4.githubusercontent.com #151.101.184.133 avatars5.githubusercontent.com #151.101.184.133 avatars6.githubusercontent.com #151.101.184.133 avatars7.githubusercontent.com #151.101.184.133 avatars8.githubusercontent.com # GitHub End windows系统的hosts文件的位置如下：C:\\Windows\\System32\\drivers\\etc\\hosts mac/linux系统的hosts文件的位置如下：/etc/hosts 然后记得cmd运行以下代码清缓存 ipconfig /flushdns ","link":"https://UFOAlastor.github.io/github_pic/"},{"title":" GitHub中国访问加速","content":"GitHub中国访问加速 解决方法：修改Hosts文件 1、访问 IP-LookUp 2、分别查询 github.com 和 github.global.ssl.fastly.net 对应的 IP地址 3、修改hosts文件，添加两行，例如： 140.82.112.4 github.com 199.232.69.194 github.global.ssl.fastly.net 具体以自己获得的为准 windows系统的hosts文件的位置如下：C:\\Windows\\System32\\drivers\\etc\\hosts mac/linux系统的hosts文件的位置如下：/etc/hosts 添加进host文件中即可： 4.cmd运行以下代码刷新DNS ipconfig /flushdns ","link":"https://UFOAlastor.github.io/github_speed/"},{"title":"Win10卸载更新","content":"Win10卸载更新 winbugs的更新每次修复一些bug，添加一些bug。 有时候更新完的还不如更新前的版本，怎么办呢？ 其实可以选择卸载掉更新，这样可以恢复更新前的状态 点击进入查看更新历史记录，选择卸载更新 就可以看到自己最新更新的内容，不需要的话就卸载即可 卸载了的更新还是可以选择安装的，不用担心 ps：最近微软1909更新优化了一些型号的cpu的速度，我的破电脑因此突然跑得飞快，但是一次03更新后有变卡了，于是我把更新给卸载了 😄 ","link":"https://UFOAlastor.github.io/win10_delete_update/"},{"title":"Typora+PicGo-core插入图片自动上传","content":"Typora+PicGo-core插入图片自动上传 注意：请确保node.js版本为新版（大于V8）node.js官网下载地址 1.安装PicGo-Core 上传服务选择PicGo-Core后，点击下载或更新，会自动下载好最新版本 等待安装完成后，验证图片上传功能，会发现无法使用 2. 复制下图片中所示的路径，打开cmd cd C:\\Users\\你的用户名\\AppData\\Roaming\\Typora\\picgo\\win64 .\\picgo.exe install smms-user .\\picgo.exe install gitee-uploader .\\picgo.exe install github-plus 执行如上命令（可以看出来是smms，gitee，github的插件安装，按需安装） 3. 配置PicGO-Core 安装完后，点击打开配置文件 复制上以下代码： { &quot;picBed&quot;: { &quot;current&quot;: &quot;gitee&quot;, &quot;uploader&quot;: &quot;gitee&quot;, &quot;githubPlus&quot;: { &quot;branch&quot;: &quot;master&quot;, &quot;customUrl&quot;: &quot;https://cdn.jsdelivr.net/gh/用户名/项目名&quot;, &quot;path&quot;: &quot;img/&quot;, &quot;repo&quot;: &quot;github用户名/github仓库名&quot;, &quot;token&quot;: &quot;自己的token&quot; }, &quot;gitee&quot;: { &quot;branch&quot;: &quot;master&quot;, &quot;customPath&quot;: &quot;yearMonth&quot;, &quot;customUrl&quot;: &quot;&quot;, &quot;path&quot;: &quot;img/&quot;, &quot;repo&quot;: &quot;gitee用户名/gitee仓库名&quot;, &quot;token&quot;: &quot;自己的token&quot; }, &quot;smms-user&quot;: { &quot;Authorization&quot;: &quot;替换成你自己的token&quot; }, &quot;transformer&quot;: &quot;path&quot; }, &quot;picgoPlugins&quot;: { &quot;picgo-plugin-gitee-uploader&quot;: true, &quot;picgo-plugin-smms-user&quot;: true, &quot;picgo-plugin-github-plus&quot;: true } } 注：因国内raw.githubusercontent.com地址被墙，这里github的自定义url为cdn地址&quot;customUrl&quot;: “https://cdn.jsdelivr.net/gh/用户名/项目名” 如何创建github项目和gitee项目这里不做过多赘述，网上教程很多。这里只拿gitee做个示例。注意下图框选出的红色区域就可以了。 进入个人设置，生成令牌token 注意token只会显示一次，记得立马保存起来 smms的token在此网页申请： https://sm.ms/home/apitoken 4. 体验上传 设置好并保存配置文件，再次点击验证图片上传就正常上传了。 （因为我忘记截图了，再上传一次的提示不一样，就借用下网图展示验证成功的画面，如果侵犯了您的权益请与我联系，一切仅供学习交流） ","link":"https://UFOAlastor.github.io/PicGo-Core_and_Typora/"},{"title":"图片按钮","content":"图片按钮 效果如下 代码： &lt;p&gt;&lt;img src=&quot;http://www.nyan.cat/cats/original.gif&quot; onclick=&quot;javascript:location.href='/NYAN_CAT/NYAN_CAT.html'&quot;&gt;&lt;/p&gt; PS：网站下方的彩虹猫也是哦 😄 ","link":"https://UFOAlastor.github.io/pic_button/"},{"title":"纯CSS炫酷的按钮","content":"纯CSS炫酷的按钮 CSS代码 .fill:hover, .fill:focus { -webkit-box-shadow: inset 0 0 0 2em var(--hover); box-shadow: inset 0 0 0 2em var(--hover); } .pulse:hover, .pulse:focus { -webkit-animation: pulse 1s; animation: pulse 1s; -webkit-box-shadow: 0 0 0 2em rgba(255, 255, 255, 0); box-shadow: 0 0 0 2em rgba(255, 255, 255, 0); } @-webkit-keyframes pulse { 0% { -webkit-box-shadow: 0 0 0 0 var(--hover); box-shadow: 0 0 0 0 var(--hover); } } @keyframes pulse { 0% { -webkit-box-shadow: 0 0 0 0 var(--hover); box-shadow: 0 0 0 0 var(--hover); } } .close:hover, .close:focus { -webkit-box-shadow: inset -3.5em 0 0 0 var(--hover), inset 3.5em 0 0 0 var(--hover); box-shadow: inset -3.5em 0 0 0 var(--hover), inset 3.5em 0 0 0 var(--hover); } .raise:hover, .raise:focus { -webkit-box-shadow: 0 0.5em 0.5em -0.4em var(--hover); box-shadow: 0 0.5em 0.5em -0.4em var(--hover); -webkit-transform: translateY(-0.25em); transform: translateY(-0.25em); } .up:hover, .up:focus { -webkit-box-shadow: inset 0 -3.25em 0 0 var(--hover); box-shadow: inset 0 -3.25em 0 0 var(--hover); } .slide:hover, .slide:focus { -webkit-box-shadow: inset 6.5em 0 0 0 var(--hover); box-shadow: inset 6.5em 0 0 0 var(--hover); } .offset { -webkit-box-shadow: 0.3em 0.3em 0 0 var(--color), inset 0.3em 0.3em 0 0 var(--color); box-shadow: 0.3em 0.3em 0 0 var(--color), inset 0.3em 0.3em 0 0 var(--color); } .offset:hover, .offset:focus { -webkit-box-shadow: 0 0 0 0 var(--hover), inset 6em 3.5em 0 0 var(--hover); box-shadow: 0 0 0 0 var(--hover), inset 6em 3.5em 0 0 var(--hover); } .fill { --color: #a972cb; --hover: #cb72aa; } .pulse { --color: #ef6eae; --hover: #ef8f6e; } .close { --color: #ff7f82; --hover: #ffdc7f; } .raise { --color: #ffa260; --hover: #e5ff60; } .up { --color: #e4cb58; --hover: #94e458; } .slide { --color: #8fc866; --hover: #66c887; } .offset { --color: #19bc8b; --hover: #1973bc; } button { color: var(--color); -webkit-transition: 0.25s; transition: 0.25s; } button:hover, button:focus { border-color: var(--hover); color: #fff; } button { background: none; border: 2px solid; font: inherit; line-height: 1; margin: 0.5em; padding: 1em 2em; } Html代码 &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;fill&quot;&gt;Fill In&lt;/button&gt; &lt;button class=&quot;pulse&quot;&gt;Pulse&lt;/button&gt; &lt;button class=&quot;close&quot;&gt;Close&lt;/button&gt; &lt;button class=&quot;raise&quot;&gt;Raise&lt;/button&gt; &lt;button class=&quot;up&quot;&gt;Fill Up&lt;/button&gt; &lt;button class=&quot;slide&quot;&gt;Slide&lt;/button&gt; &lt;button class=&quot;offset&quot;&gt;Offset&lt;/button&gt; &lt;/div&gt; 搬运自: https://developer.mozilla.org/en/docs/Web/CSS/box-shadow box-shadow: [inset?] [top] [left] [blur] [size] [color]; Tips: We're setting all the blurs to 0 since we want a solid fill. - Add the inset keyword so the box-shadow is on the inside of the element Animating the inset shadow on hover looks like the element is filling in from whatever side you specify ([top] and [left] accept negative values to become [bottom] and [right]) Multiple shadows can be stacked If you're animating multiple shadows, be sure to keep the same number of shadows so the animation is smooth. Otherwise, you'll get something choppy. ","link":"https://UFOAlastor.github.io/css_button/"},{"title":"Markdown语法","content":"部分在此博客中显示错误，请移步以下链接： Markdown学习 Markdown学习 标题索引 标题 文本 列表 区块 代码 链接 图片 表格 Html元素 公式 流程图 1、横向流程图源码格式： 2、竖向流程图源码格式： 3、标准流程图源码格式： 4、标准流程图源码格式（横向）： 5、UML时序图源码样例： 6、UML时序图源码复杂样例： 7、UML标准时序图样例： 8、甘特图样例： 标题索引 [Toc] 其中gridea中语法为 @[Toc] 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 文本 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 斜体文本 斜体文本 粗体文本 粗体文本 粗斜体文本 粗斜体文本 *** * * * ***** - - - ---------- ~~删除线~~ 删除线 &lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 [^要注明的文本] 创建脚注格式类似这样 [^Zander]。 [^Zander]: 最牛逼的蒟蒻:D 创建脚注格式类似这样 [1]。 列表 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第二个元素 区块 &gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套 最外层 第一层嵌套 第二层嵌套 代码 ​```javascript $(document).ready(function () { alert('RUNOOB'); }); ​``` $(document).ready(function () { alert('RUNOOB'); }); 链接 [链接名称](链接地址) 或者 &lt;链接地址&gt; 图片 ![alt 属性文本](图片地址 &quot;可选标题&quot;) 表格 | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 Html元素 使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 使用 Ctrl+Alt+Del 重启电脑 公式 $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\ \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\ \\end{vmatrix} ${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}} $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}} 流程图 1、横向流程图源码格式： ​```mermaid graph LR A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] ​``` graph LR A[方形] --&gt;B(圆角) B --&gt; C{条件a} C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式： ​```mermaid graph TD A[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] ​``` graph TD A[方形] --&gt; B(圆角) B --&gt; C{条件a} C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式： ​```flow st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op ​``` st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op 4、标准流程图源码格式（横向）： ​```flow st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st(right)-&gt;op(right)-&gt;cond cond(yes)-&gt;io(bottom)-&gt;e cond(no)-&gt;sub1(right)-&gt;op ​``` st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st(right)-&gt;op(right)-&gt;cond cond(yes)-&gt;io(bottom)-&gt;e cond(no)-&gt;sub1(right)-&gt;op 5、UML时序图源码样例： ​```sequence 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象A-&gt;对象B: 你真的好吗？ ​``` 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象A-&gt;对象B: 你真的好吗？ 6、UML时序图源码复杂样例： ​```sequence Title: 标题：复杂使用 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象B-&gt;小三: 你好吗 小三--&gt;&gt;对象A: 对象B找我了 对象A-&gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 ​``` Title: 标题：复杂使用 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象B-&gt;小三: 你好吗 小三--&gt;&gt;对象A: 对象B找我了 对象A-&gt;对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 7、UML标准时序图样例： ​```mermaid %% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! ​``` %% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 8、甘特图样例： ​```mermaid %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h ​``` %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h 最牛的蒟蒻 😄 ↩︎ ","link":"https://UFOAlastor.github.io/markdown/"},{"title":"网站中添加代码高亮js","content":"先来个效果图 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define res register int const int MAXN=100000+10; ll n,k,total,s[MAXN]; map&lt;ll,bool&gt; mmp; int main(){ cin&gt;&gt;n&gt;&gt;k; for(res i=1;i&lt;=n;++i) cin&gt;&gt;s[i]; sort(s+1,s+n+1); for(res i=1;i&lt;=n;++i){ if(!mmp[s[i]]&amp;&amp;(s[i]%k||!mmp[s[i]/k])) mmp[s[i]]=1,++total; } cout&lt;&lt;total; return 0; } 这里推荐使用Highlight.js 首先从上面超链接进入官网 点击如图所示按钮进入下载界面 往下翻，是各类语言的选项，基本上用默认的配置就够了 选完后，点击下载 之后解压下载得到的文件，可以看到这些东西 如果是Gridea用户，将文件放入static文件夹即可。其他用户自行放入相应的配置文件夹中 现在我们已经有了基础文件，开始配置网页源文件 Gridea用户进入使用的主题文件夹 因为是代码的高亮，基本只有文章中会用到，所以只修改post的配置即可 在头部添加代码： 代码如下： &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/styles/railscasts.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/styles/default.css&quot;&gt; &lt;script src=&quot;/highlight.pack.js&quot;&gt;&lt;/script&gt; &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 至此已经配置完毕，大功告成！去看看效果吧 😄 ","link":"https://UFOAlastor.github.io/web_blog_highlightjs/"},{"title":"网站访问量统计js","content":"网站访问量统计js &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; &lt;sup style=&quot;color:grey&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/sup&gt; &lt;/span&gt; &lt;sup&gt;&lt;span style=&quot;color:grey&quot; class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/sup&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; &lt;sup style=&quot;color:grey&quot;&gt;访问人数&lt;span id=&quot;busuanzi_value_site_uv&quot; &gt;&lt;/span&gt;位&lt;/sup&gt; &lt;/span&gt; &lt;sup&gt;&lt;span style=&quot;color:grey&quot; class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/sup&gt; &lt;span id=&quot;/&lt;%= post.fileName %&gt;/&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&lt;%= post.title %&gt;&quot;&gt; &lt;sup style=&quot;color:grey&quot; class=&quot;post-meta-item-text&quot;&gt;阅读量&lt;/sup&gt; &lt;sup style=&quot;color:grey&quot; class=&quot;leancloud-visitors-count&quot;&gt;&lt;/sup&gt; &lt;/span&gt; 将这段代码加入到网页源文件中（gridea用户加入到主题文件中） 然后可以在本地先测试，但是这时候会显示非常大的数值，因为这个js是按照网址来计算的，所以本地测试就是所有这样干过的用户的数据 确认字体，颜色之类的满意后就可以上传使用啦 😄 ","link":"https://UFOAlastor.github.io/web_visitors/"},{"title":"初识git——上传文件指令","content":"git上传文件指令 git init 将当前目录初始化为git管理目录（多出.git文件夹） git add . 将当前目录下所有文件添加到待上传队列中 也可以单独添加特定文件 git commit -m &quot;first commit&quot; 添加上传的备注，必须添加，随便写点即可 git remote add origin https://XXX 添加要上传到的仓库地址 git push origin master 进行上传操作，到达origin的地址上传到master分支下 其中第一次上传使用 git push -u origin master ，关于-u的含义看这个 错误时强制上传使用 git push --force origin master 之后如果是第一次上传会有输入密码的提示框出现，填写即可 ","link":"https://UFOAlastor.github.io/git_push/"},{"title":"kaios端网易云音乐播放器","content":"kaios端第三方网易云音乐 原html播放器作者：墨渊 最初移植者：QQ老冰 后续更新者：此店不售此书（Zander Alastor） 示例图片： 应用介绍： 一款Kaios端网易云音乐随机播放器 歌曲在指定歌单中随机进行播放（可以修改歌单） 界面简洁，功能完善（大概？），使用简易 使用说明： （1.3.7 正式版） 上下方向键控制音量大小 左右方向键控制歌曲前后快进 左长条键（接听键上方的）控制歌曲单首循环 右长条键（挂断键上方的）控制下一首 歌曲播放完毕自动下一首（开启循环后自动重新播放） 歌单修改说明： 默认歌单为此店不售此书（死宅一枚）的歌单，充斥着二次元，纯音乐，游戏原声等，不喜勿喷，请按照以下方法修改！ 解压应用压缩包，并且解压内部的application： 进入application，然后进入js文件夹： 使用文本编辑器打开index.js： 修改此位置的mid数值： 其中mid的获取： ​ 登入网页版网易云音乐，进入需要的歌单： 网址后数值即为mid数值，修改后应用播放的就是这个歌单！ 下载方式： Github项目：https://github.com/UFOAlastor/Kaios_music_player 百度云: https://pan.baidu.com/s/1nICx865K1xY6YgK6A7ektw 提取码: utrc lanzous：https://www.lanzous.com/ib4z6hi 密码:CDBSCS 版本介绍： 1.3.7 正式版 ：此店不售此书制作，修正按键控制时 下一首 没有按动效果的bug 1.3.6 正式版 ：此店不售此书制作，添加进度控制，长按左右方向键快进！ 1.3.5 正式版 ：此店不售此书制作，去除鼠标（以前为虚拟鼠标控制），进入按键控制时代（笑 。。。互相占用版本号，具体内容无从考据 1.3.1 正式版 ：小白一枚制作，此版本为歌单版本，并使用了全新的播放界面，与此店不售此书维护的版本共用版本号，但其实已经不属于同个应用 1.3.0 正式版 ：小白一枚，添加音量控制功能（是的，之前连音量都没法改XD） 1.2.8 正式版 ：此店不售此书制作，添加自动下一首功能 。。。各种小更新及修正占用版本号 1.0.0 正式版 ：此店不售此书制作，添加循环播放功能 。。。各种被遗忘的更新 0.0.3 beta ：魔改横屏版，具体作者？ 0.0.2 beta ：LiarOnce修正画面比例 0.0.1 beta ：QQ老冰移植，鼠标控制，仅能播放，不支持自动下一首，画面不对称（小吐槽） 转载说明： 如果想要转载这篇文章及应用本身，需向本人取得许可，具体事项参照转载说明 ","link":"https://UFOAlastor.github.io/kaios_Music163/"},{"title":"纯CSS制作的精美部件","content":"全部为css+html！没有使用js！ 仿太阳系行星转动 会动的渐变色背景 叠叠高游戏 3D仿真玻璃管进度条 出故障的文字 HTML 和 CSS 制作艺术品！（下面表示用css做出来的画） 肖像画 手机：) 地图创作器 图像自动化滤镜 渐变效果按钮 ","link":"https://UFOAlastor.github.io/CSS_design/"},{"title":"转载说明","content":"转载说明 所有文章的转载需在文章开篇标明原作者及来源 格式如下： 原作者：此店不售此书（Zander Alastor） 原地址：*原文链接* 条件允许情况下应使用超链接格式： 原作者：[此店不售此书（Zander Alastor）](*原文链接*) 文章转载 需先经过本人同意 请求需通过邮件发送至指定邮箱：ZanderAlastor@qq.com 资源转载 必须使用本人提供的下载方式 特殊情况 在请求邮件超过三日未得到本人回复的情况下，允许获得临时转载许可，并依照第一条的格式进行转载 最终转载许可依照本人回复 Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0) ","link":"https://UFOAlastor.github.io/Reprint/"},{"title":"Gridea深度定制——留言","content":"我的主题inlineAMP自带的留言系统不好用，怎么办呢？ 我们要自定义添加留言系统！ 观看教程前请确保已经看过start篇 这里推荐的是Valine留言系统，非常好用 1.按照Valine的要求进行配置，然后我们获取了APP ID 和 APP Key，和如下代码段 &lt;head&gt; .. &lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; &lt;script&gt; new Valine({ el: '#vcomments', appId: '&lt;API_ID&gt;', appKey: '&lt;API_Key&gt;' }) &lt;/script&gt; &lt;/body&gt; 2.找到我们要修改的位置： 比如： 我要修改post（即文章界面，不包括主页） 那么就在我们的主题文件夹里找到他，并文本编辑器打开它： 3.在head部分添加第一段代码 4.在中间合适的位置添加第二段代码： 5.然后去Gridea中点击预览即可！大功告成 ","link":"https://UFOAlastor.github.io/Gridea_Valine/"},{"title":"Gridea深度定制——start","content":"Gridea的全程图形化编辑，入门非常简单，但是深度定制时却显简陋 这里讲解如何深度定制Gridea搭建的博客 首先，我们要认识到一点，由Gridea搭建的博客无法直接修改网页源文件。 尽管我们能够知道储存目录，但是Gridea每次会格式化源文件，这样我们无法便捷地长期保留更改 （每次Gridea上传都会覆盖我们自己的修改）。 所以我们要从其他途径进行修改！ 来自Gridea制作者的回复：“你可以试试直接改主题源代码” 是的，我们可以从主题源代码入手！ 我们可以轻松的找到主题源代码的储存位置（不知道的看这个） 进入我们正在使用的主题,可以看到如下： 其中红线圈出的部分（config.json），绝对不能修改！ 已经发现会有这样的bug：修改config.json后Gridea无法定义储存位置！ 而绿色的部分是我们需要修改的文件夹，点进去 可以看到这样的内容： 每个主题会有不同，我这里是inlineAMP主题 后缀是统一的ejs后缀，可以直接当作html/css/js打开，现在可以按照编辑网页打方式随意更改了！ 跳转链接： 留言定制篇 ","link":"https://UFOAlastor.github.io/Gridea_design/"},{"title":"Gridea主题食用方法","content":"我们知道这是个非常傻瓜式的静态网站部署软件，但是由于起步初期，用户较少，相关的教程还不够全面。 这里讲解一下主题的使用方法。 首先，我们要设置Gridea的存储目录（默认是空白的，不知道存哪里了） 点击最左下角设置图标，进入设置界面： 看到圈中的内容，这就是储存位置，我们等下要用到，请使用查找方便的位置 然后进入官网下载所需的主题 将下载完成的主题（此时是压缩包格式）解压，点进文件夹，可以看到： 其中的文件夹（红线所画部分）才是我们需要的，README为作者的话 复制红线所画的文件夹到刚才我们设置的储存目录中的themes文件夹内： 放入themes文件夹内，之后重启Gridea就可以看到主题里有我们添加的主题了！ ","link":"https://UFOAlastor.github.io/Gridea_themes/"},{"title":"Kaios上使用cmd的push注意事项","content":"前排提示，此问题如若不重视，可能导致手机无限重启 前言：此问题并非所有人都会遇到，因系统版本和使用cmd或powershell而异 判断是否有问题的方式： ​ 使用adb进行pull，pull取任意应用（例如：adb pull /system/b2g/webapps/system.gaiamobile.org） ​ 情况1、如果出现以下情况（红线内部分为pull出的文件），即pull取得到的不是文件夹，而是文件夹内部分，说明你的遇到了这个bug ​ 情况2、如果是出现了“system.gaiamobile.org“文件夹，说明没有问题，一切操作可以参照BH和清水博客内容，无需担忧 如果是情况1，请继续往下看，情况2请左转离开 首先，注意我们进行的操作：adb pull /system/b2g/webapps/system.gaiamobile.org 这个操作的对象是 system.gaiamobile.org ，此对象在手机储存中为文件夹形式，但是我们pull出的结果确为文件夹内的内容。而正常的情况应当pull出的就是 system.gaiamobile.org 文件夹。说明我们遇到了一种bug。 而且！这个bug在push时也会出现，当我们从主机向手机push时，明明按照正常操作push某文件夹，但是却不起作用！原因就是，我们看似正规操作，但是push的结果确实仅仅将我们文件夹内的内容push进手机内存！这样的结果导致修改失败，甚至在修改系统关键应用时直接导致无限重启！ 解决方法： 我们搞清楚原因后就十分简单的能够解决这个问题！既然push一层文件夹时，仅仅会push进去文件夹内的内容，那么我们多建立一层文件夹，即可解决！ 具体示例： ​ 目的为push进去system.gaiamobile.org文件夹， ​ 建立new文件夹，将system.gaiamobile.org文件夹复制进new中， ​ 然后push new文件夹， ​ 结果为system.gaiamobile.org被成功push进手机内存 PS： 这个问题害的我几次无限重启，希望遇到同样问题的人可以避免👍 ​ ","link":"https://UFOAlastor.github.io/KaiOS_push_cmd/"},{"title":"测试视频播放","content":" ","link":"https://UFOAlastor.github.io/Gridea_video/"},{"title":"测试音乐播放","content":" ","link":"https://UFOAlastor.github.io/Gridea_Music/"},{"title":"OIer 生涯的主页","content":"进入洛谷页面查看 『 』镇楼 gameは始める！ 随机图 （刷新试试 - - - - - - AC：Accept，程序通过。 CE：Compile Error，编译错误。 PC：Partially Correct，部分正确。 WA：Wrong Answer，答案错误。 RE：Runtime Error，运行时错误。 TLE：Time Limit Exceeded，超出时间限制。 MLE：Memory Limit Exceeded，超出内存限制。 OLE：Output Limit Exceeded，输出超过限制。 UKE：Unknown Error，出现未知错误。 头文件 OEIS VJ 图论画图 AC比较器 【chess】 颠倒符 判素数 MS图库 events： 2018/5/21 hello world!I'm here! 2018/7/29 我竟然绿了233 2018/8/27 蓝受，又蓝了 2018/9/24 哈哈哈(ಡωಡhiahiahia总算又绿了 2018/10/1 竟然橙名了，不会是国庆奖励吧233 2018/11/12 突然红名，惊慌失措，另外第一次复赛祭，我真是太弱了 2018/11/20 noip爆炸祭 2018/12/15 &quot;成为了神牛。以后还要继续努力!&quot;祭 2019/1/1 Happy New Year! Blessing every day is a better day! 2019/1/12 AC200祭 2019/1/14 &quot;********！&quot; 2019/1/21 咕值前一千（781），这可是太棒了 2019/1/23 AC233~ 2019/1/25 提交一千祭（AC率惨不忍睹QwQ） 2019/2/15 &quot;成为了神犇。以后还要继续努力!&quot;祭 2019/11/17 The End~ 2019/11/19 （归零赛） 复活赛 2019/12/2 正式退役 孔乙己一上线，所有虐题的人便都看着他笑，有的叫道，“孔乙己，你记录又降通过率了！”他不回答，对你谷说，“要两道题，加个签到。”便看到大凶的运势。他们又故意的高声嚷道，“你一定又WA入门题了！”孔乙己睁大眼睛说，“你怎么这样凭空污人清白……”“什么清白？我前天亲眼见你做入门题，错三次。”孔乙己便涨红了脸，额上的青筋条条绽出，争辩道，“WA不能算错……WA！……OIer的事，能算错么？”接连便是难懂的话，什么“Wonderful Answer”，什么“Awful Conversation”之类，引得众人都哄笑起来：机房内外充满了快活的空气。 紫名和我挺搭（笑 ","link":"https://UFOAlastor.github.io/My_OIer_life/"},{"title":"Welcome!","content":"My name is Zander_Alastor~~此店不售此书 关于 归档 友链 why not play a game with me? ","link":"https://UFOAlastor.github.io/welcome/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 这是我的个人小站/博客 👨‍💻 站主是谁 此店不售此书（Zander Alastor） ⛹ 兴趣爱好 编程，乐高，电子制作，木工制作，动漫，我的世界，泰拉瑞亚，CSGO 📬 联系我呀 ZanderAlastor@qq.com ZanderAlastorUFO@gmail.com 🌏 社交账号 Tieba Zhihu Steam Luogu Bilibili Github Music163 ","link":"https://UFOAlastor.github.io/about/"},{"title":"题解 P3393 【逃离僵尸岛】","content":"K个城市已经被僵尸控制了，如果贸然闯入就会被感染TAT...所以不能进入！！！ 首先，注意几个细节！ 如上方大字，不能进入被控制的城市（qwq） dis距离开long long，最大值也要开的足够大！（数据超int了） 将点值附在边权上的同志们，记得最后到n点减去，然后n点可以是危险城市！ 讲下做法： 大部分dalao们都是bfs或者将k点全部看做0点来做的 本蒟蒻就直接更新k次，把每个被控制城市附近的危险城市标记 然而直接来肯定会T的飞起qwq 所以要剪枝 见代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define res register int const int MAXN=100000+100; const ll INF=0x3f3f3f3f3f3f3f3f;//dis最大值要足够大才行 int n,m,k,s,P,Q,cnt=1,head[MAXN],vis[MAXN],ban[MAXN]; ll dis[MAXN];//dis开long long struct EDGE{int to,next;}edge[MAXN&lt;&lt;2]; queue&lt;int&gt; bad; inline void E_add(int u,int v){edge[cnt]=(EDGE){v,head[u]};head[u]=cnt++;} void spfa_flag(int S){ queue&lt;int&gt; q; for(res i=1;i&lt;=n;++i) dis[i]=INF; memset(vis,0,sizeof(vis)); q.push(S),dis[S]=0; while(q.size()){ int x=q.front();q.pop(); vis[x]=0; for(res i=head[x];i;i=edge[i].next){ int y=edge[i].to,z=1; if(ban[y]!=2&amp;&amp;dis[y]&gt;dis[x]+z){ //此处注意！当y点被标记为2，说明y点是另一个被控制的城市， //我们就不用管它，跳过 dis[y]=dis[x]+1; if(dis[y]&lt;=s) ban[y]=1; //当y点到x点（一个被控城市）的距离小于s， //就标记为1，表示危险城市 if(!vis[y]&amp;&amp;dis[y]&lt;s) vis[y]=1,q.push(y); //此处注意！ //当y点到x点距离小于s才把y点加入队列， //因为如果y点到x点距离大于或等于s时，说明y点在x的危险范围的边缘， //再用y点更新最短路就没有意义，因为肯定没有距离小于s的点在y点外面 } } } } void spfa(){ queue&lt;int&gt; q; for(res i=1;i&lt;=n;++i) dis[i]=INF; memset(vis,0,sizeof(vis)); q.push(1),dis[1]=0; while(q.size()){ int x=q.front();q.pop(); vis[x]=0; for(res i=head[x];i;i=edge[i].next){ int y=edge[i].to,z=(ban[y]?Q:P); if(ban[y]!=2&amp;&amp;dis[y]&gt;dis[x]+z){//此处注意！ //当y为被控城市时不能走！！！ //（qwq我眼瞎，错了近十次才看清题目） dis[y]=dis[x]+z; if(!vis[y]) vis[y]=1,q.push(y); } } } } int main(){ scanf(&quot;%d%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;s,&amp;P,&amp;Q); for(res i=1;i&lt;=k;++i){ int x; scanf(&quot;%d&quot;,&amp;x);ban[x]=2,bad.push(x); }//被控制城市标记为2，然后存bad队列中 for(res i=1;i&lt;=m;++i){ int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); E_add(x,y),E_add(y,x); } while(bad.size()){ spfa_flag(bad.front());bad.pop(); } spfa(); if(ban[n]) dis[n]-=Q;//在n点减去花费，以为n点不收钱 else dis[n]-=P;//还有一件事，n点可以为危险城市！！ printf(&quot;%lld&quot;,dis[n]); return 0; } ","link":"https://UFOAlastor.github.io/Fiqnn6LGM/"},{"title":"题解 P1978 【集合】","content":"然而我是用map的 首先，根据题意打暴力就行 然后有几个细节要注意： 开 long long ！！！ 本来是sort 从大到小 或 从小到大都可以， 然而 从大到小 的话，就要用 *s[i]k，这样会爆long long（开__int128也会爆qwq） 所以用从小到大，那么为了判段就必须写 s[i]/k, 但是它没有整除会进1，然后就40了qwq， 所以要用 s[i]%k || !mmp[s[i]/k] (意思是不能整除肯定就可以了，可以整除再判断） 见代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define res register int const int MAXN=100000+10; ll n,k,total,s[MAXN]; map&lt;ll,bool&gt; mmp; int main(){ cin&gt;&gt;n&gt;&gt;k; for(res i=1;i&lt;=n;++i) cin&gt;&gt;s[i]; sort(s+1,s+n+1); for(res i=1;i&lt;=n;++i){ if(!mmp[s[i]]&amp;&amp;(s[i]%k||!mmp[s[i]/k])) mmp[s[i]]=1,++total; } cout&lt;&lt;total; return 0; } ","link":"https://UFOAlastor.github.io/HrF64BtBr/"},{"title":"题解 UVA534 【Frogger】","content":"这题就非常有意思了 首先，这是一道floyed妙用题 我们要对floyed进行简单的修改 先看下题意，要我们求青蛙距离 简单讲就是更小的跳跃距离，无视总路程 那么我们知道floyed是求最短路径的算法，并且是动态规划思想 那么我们只要将转移方程改改不就行了么 那么该怎么改哩 1.首先判断要改 floyed求最短路径是在找到更优路时更新 我们要改成：判断一条路是否可以分割成更短的两条路 如图：（比较粗糙不要介意233） 点A____________________点B \\ / \\ / \\ / 点C / 我们可以看出来AC或BC的长度是比AB短的 这就满足if条件 2.然后是处理 这就用AB，AC中更长的一个替换AB，即BC 为什么是更长的一个？ 因为题目要求输出最大青蛙距离，就是最小值中的最大值 这样我们就有了核心代码： for(res k=1;k&lt;=m;++k) for(res i=1;i&lt;=m;++i) for(res j=1;j&lt;=m;++j) if(mmp[i][j]&gt;mmp[i][k]&amp;&amp;mmp[i][j]&gt;mmp[k][j]){ mmp[i][j]=mmp[j][i]=max(mmp[i][k],mmp[k][j]); } 如果有不明白的，可以先模拟下 哪里讲的不好还请谅解，有问题可以私信我qwq ","link":"https://UFOAlastor.github.io/Wrmg0wuHg/"},{"title":"题解 P1739 【表达式括号匹配】","content":"这题都不用储存，直接处理。 要排除开头是 ‘ ）’ 加个flag判断就行。 括号匹配的问题： 因为都是成对的，所以找到一个‘ ） ’ 就让‘ （ ’的总数t自减， 在t为0时，就说明前面没有与现在找到的 ‘ ） ’对应的‘ （ ’， 可以直接flag=0。 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int t=0; bool flag=1; char ch; while((ch=getchar())!='@'){ if(ch=='('){ t++; } if(ch==')'){ if(t) t--; else flag=0; } } if(t==0&amp;&amp;flag) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0; } 第一次交题解，没说清楚还请多多包涵 &gt;_&lt; ","link":"https://UFOAlastor.github.io/UcK2Xl1RR/"}]}